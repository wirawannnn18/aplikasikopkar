<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Task 14: Final Checkpoint - Dashboard Analytics KPI</title>
    <link rel="stylesheet" href="css/dashboard-responsive.css">
    <link rel="stylesheet" href="css/dashboard-customization.css">
    <link rel="stylesheet" href="css/lazy-loading.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fast-check/3.13.2/fast-check.min.js"></script>
    <style>
        .test-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        .test-section {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            margin-bottom: 30px;
        }
        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .test-item {
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            transition: all 0.3s ease;
        }
        .test-item.passed {
            border-color: #4caf50;
            background-color: #f1f8e9;
        }
        .test-item.failed {
            border-color: #f44336;
            background-color: #ffebee;
        }
        .test-item.running {
            border-color: #ff9800;
            background-color: #fff3e0;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-passed { background-color: #4caf50; }
        .status-failed { background-color: #f44336; }
        .status-running { background-color: #ff9800; }
        .status-pending { background-color: #9e9e9e; }
        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #8bc34a);
            transition: width 0.3s ease;
        }
        .test-results {
            margin-top: 20px;
            padding: 15px;
            background-color: #f5f5f5;
            border-radius: 8px;
        }
        .summary-stats {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
        }
        .stat-item {
            text-align: center;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #333;
        }
        .stat-label {
            color: #666;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <div class="test-header">
            <h1>üéØ Task 14: Final Checkpoint</h1>
            <p>Dashboard Analytics & KPI - Comprehensive Test Suite</p>
            <div class="progress-bar">
                <div class="progress-fill" id="overallProgress" style="width: 0%"></div>
            </div>
        </div>
        <div class="summary-stats">
            <div class="stat-item">
                <div class="stat-number" id="totalTests">0</div>
                <div class="stat-label">Total Tests</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="passedTests">0</div>
                <div class="stat-label">Passed</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="failedTests">0</div>
                <div class="stat-label">Failed</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="successRate">0%</div>
                <div class="stat-label">Success Rate</div>
            </div>
        </div>

        <div class="test-section">
            <h2>üèóÔ∏è Core Infrastructure Tests</h2>
            <div class="test-grid" id="infrastructureTests">
                <div class="test-item" data-test="dashboard-setup">
                    <span class="status-indicator status-pending"></span>
                    <strong>Dashboard Setup</strong>
                    <p>Verify dashboard initialization and configuration</p>
                </div>
                <div class="test-item" data-test="widget-management">
                    <span class="status-indicator status-pending"></span>
                    <strong>Widget Management</strong>
                    <p>Test widget creation, update, and removal</p>
                </div>
                <div class="test-item" data-test="analytics-engine">
                    <span class="status-indicator status-pending"></span>
                    <strong>Analytics Engine</strong>
                    <p>Validate KPI calculations and metrics</p>
                </div>
                <div class="test-item" data-test="chart-rendering">
                    <span class="status-indicator status-pending"></span>
                    <strong>Chart Rendering</strong>
                    <p>Test chart generation and visualization</p>
                </div>
            </div>
        </div>
        <div class="test-section">
            <h2>üìä Analytics & Data Tests</h2>
            <div class="test-grid" id="analyticsTests">
                <div class="test-item" data-test="member-analytics">
                    <span class="status-indicator status-pending"></span>
                    <strong>Member Analytics</strong>
                    <p>Test member segmentation and activity analysis</p>
                </div>
                <div class="test-item" data-test="data-aggregation">
                    <span class="status-indicator status-pending"></span>
                    <strong>Data Aggregation</strong>
                    <p>Verify data processing and aggregation</p>
                </div>
                <div class="test-item" data-test="statistical-analysis">
                    <span class="status-indicator status-pending"></span>
                    <strong>Statistical Analysis</strong>
                    <p>Test correlation and regression analysis</p>
                </div>
                <div class="test-item" data-test="anomaly-detection">
                    <span class="status-indicator status-pending"></span>
                    <strong>Anomaly Detection</strong>
                    <p>Validate anomaly detection algorithms</p>
                </div>
            </div>
        </div>

        <div class="test-section">
            <h2>üé® UI/UX & Responsiveness Tests</h2>
            <div class="test-grid" id="uiTests">
                <div class="test-item" data-test="responsive-layout">
                    <span class="status-indicator status-pending"></span>
                    <strong>Responsive Layout</strong>
                    <p>Test mobile and desktop layouts</p>
                </div>
                <div class="test-item" data-test="dashboard-customization">
                    <span class="status-indicator status-pending"></span>
                    <strong>Dashboard Customization</strong>
                    <p>Test drag-drop and widget configuration</p>
                </div>
                <div class="test-item" data-test="role-based-access">
                    <span class="status-indicator status-pending"></span>
                    <strong>Role-Based Access</strong>
                    <p>Verify user permissions and access control</p>
                </div>
                <div class="test-item" data-test="user-preferences">
                    <span class="status-indicator status-pending"></span>
                    <strong>User Preferences</strong>
                    <p>Test preference management and persistence</p>
                </div>
            </div>
        </div>
        <div class="test-section">
            <h2>‚ö° Performance & Optimization Tests</h2>
            <div class="test-grid" id="performanceTests">
                <div class="test-item" data-test="loading-performance">
                    <span class="status-indicator status-pending"></span>
                    <strong>Loading Performance</strong>
                    <p>Verify 3-second load time requirement</p>
                </div>
                <div class="test-item" data-test="caching-system">
                    <span class="status-indicator status-pending"></span>
                    <strong>Caching System</strong>
                    <p>Test data caching and TTL behavior</p>
                </div>
                <div class="test-item" data-test="auto-refresh">
                    <span class="status-indicator status-pending"></span>
                    <strong>Auto-Refresh</strong>
                    <p>Validate 5-minute refresh intervals</p>
                </div>
                <div class="test-item" data-test="mobile-optimization">
                    <span class="status-indicator status-pending"></span>
                    <strong>Mobile Optimization</strong>
                    <p>Test mobile performance and data usage</p>
                </div>
            </div>
        </div>

        <div class="test-section">
            <h2>üì§ Export & Reporting Tests</h2>
            <div class="test-grid" id="exportTests">
                <div class="test-item" data-test="export-manager">
                    <span class="status-indicator status-pending"></span>
                    <strong>Export Manager</strong>
                    <p>Test PDF and Excel export functionality</p>
                </div>
                <div class="test-item" data-test="report-builder">
                    <span class="status-indicator status-pending"></span>
                    <strong>Report Builder</strong>
                    <p>Verify custom report generation</p>
                </div>
                <div class="test-item" data-test="format-preservation">
                    <span class="status-indicator status-pending"></span>
                    <strong>Format Preservation</strong>
                    <p>Test data accuracy in exports</p>
                </div>
            </div>
        </div>
        <div class="test-section">
            <h2>üîß Error Handling & Recovery Tests</h2>
            <div class="test-grid" id="errorTests">
                <div class="test-item" data-test="error-handling">
                    <span class="status-indicator status-pending"></span>
                    <strong>Error Handling</strong>
                    <p>Test error detection and recovery</p>
                </div>
                <div class="test-item" data-test="connection-monitoring">
                    <span class="status-indicator status-pending"></span>
                    <strong>Connection Monitoring</strong>
                    <p>Verify network failure handling</p>
                </div>
                <div class="test-item" data-test="graceful-degradation">
                    <span class="status-indicator status-pending"></span>
                    <strong>Graceful Degradation</strong>
                    <p>Test fallback to cached data</p>
                </div>
            </div>
        </div>

        <div class="test-section">
            <h2>üß™ Property-Based Tests</h2>
            <div class="test-grid" id="propertyTests">
                <div class="test-item" data-test="financial-calculations">
                    <span class="status-indicator status-pending"></span>
                    <strong>Financial Calculations</strong>
                    <p>Verify mathematical accuracy of KPIs</p>
                </div>
                <div class="test-item" data-test="data-consistency">
                    <span class="status-indicator status-pending"></span>
                    <strong>Data Consistency</strong>
                    <p>Test data integrity across operations</p>
                </div>
                <div class="test-item" data-test="performance-thresholds">
                    <span class="status-indicator status-pending"></span>
                    <strong>Performance Thresholds</strong>
                    <p>Validate performance requirements</p>
                </div>
            </div>
        </div>

        <div class="test-results">
            <h3>üìã Test Execution Log</h3>
            <div id="testLog" style="max-height: 300px; overflow-y: auto; background: white; padding: 15px; border-radius: 8px;">
                <p><em>Test execution will begin shortly...</em></p>
            </div>
        </div>

        <div style="text-align: center; margin-top: 30px;">
            <button id="runAllTests" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; padding: 15px 30px; border-radius: 8px; font-size: 16px; cursor: pointer;">
                üöÄ Run All Tests
            </button>
        </div>
    </div>
    <!-- Load Dashboard Components -->
    <script src="js/dashboard/types.js"></script>
    <script src="js/dashboard/DashboardController.js"></script>
    <script src="js/dashboard/WidgetManager.js"></script>
    <script src="js/dashboard/AnalyticsEngine.js"></script>
    <script src="js/dashboard/ChartRenderer.js"></script>
    <script src="js/dashboard/MemberAnalytics.js"></script>
    <script src="js/dashboard/DataAggregator.js"></script>
    <script src="js/dashboard/StatisticalAnalyzer.js"></script>
    <script src="js/dashboard/AnomalyDetector.js"></script>
    <script src="js/dashboard/ResponsiveLayoutManager.js"></script>
    <script src="js/dashboard/DashboardCustomizer.js"></script>
    <script src="js/dashboard/RoleBasedAccessControl.js"></script>
    <script src="js/dashboard/UserPreferencesManager.js"></script>
    <script src="js/dashboard/CacheManager.js"></script>
    <script src="js/dashboard/AutoRefreshManager.js"></script>
    <script src="js/dashboard/MobileOptimizer.js"></script>
    <script src="js/dashboard/ExportManager.js"></script>
    <script src="js/dashboard/ReportBuilder.js"></script>
    <script src="js/dashboard/ErrorHandler.js"></script>
    <script src="js/dashboard/ConnectionMonitor.js"></script>

    <script>
        class FinalCheckpointTester {
            constructor() {
                this.tests = [];
                this.results = {
                    total: 0,
                    passed: 0,
                    failed: 0
                };
                this.logElement = document.getElementById('testLog');
                this.initializeTests();
            }

            initializeTests() {
                // Core Infrastructure Tests
                this.addTest('dashboard-setup', 'Dashboard Setup', this.testDashboardSetup.bind(this));
                this.addTest('widget-management', 'Widget Management', this.testWidgetManagement.bind(this));
                this.addTest('analytics-engine', 'Analytics Engine', this.testAnalyticsEngine.bind(this));
                this.addTest('chart-rendering', 'Chart Rendering', this.testChartRendering.bind(this));

                // Analytics & Data Tests
                this.addTest('member-analytics', 'Member Analytics', this.testMemberAnalytics.bind(this));
                this.addTest('data-aggregation', 'Data Aggregation', this.testDataAggregation.bind(this));
                this.addTest('statistical-analysis', 'Statistical Analysis', this.testStatisticalAnalysis.bind(this));
                this.addTest('anomaly-detection', 'Anomaly Detection', this.testAnomalyDetection.bind(this));
                // UI/UX & Responsiveness Tests
                this.addTest('responsive-layout', 'Responsive Layout', this.testResponsiveLayout.bind(this));
                this.addTest('dashboard-customization', 'Dashboard Customization', this.testDashboardCustomization.bind(this));
                this.addTest('role-based-access', 'Role-Based Access', this.testRoleBasedAccess.bind(this));
                this.addTest('user-preferences', 'User Preferences', this.testUserPreferences.bind(this));

                // Performance & Optimization Tests
                this.addTest('loading-performance', 'Loading Performance', this.testLoadingPerformance.bind(this));
                this.addTest('caching-system', 'Caching System', this.testCachingSystem.bind(this));
                this.addTest('auto-refresh', 'Auto-Refresh', this.testAutoRefresh.bind(this));
                this.addTest('mobile-optimization', 'Mobile Optimization', this.testMobileOptimization.bind(this));

                // Export & Reporting Tests
                this.addTest('export-manager', 'Export Manager', this.testExportManager.bind(this));
                this.addTest('report-builder', 'Report Builder', this.testReportBuilder.bind(this));
                this.addTest('format-preservation', 'Format Preservation', this.testFormatPreservation.bind(this));

                // Error Handling & Recovery Tests
                this.addTest('error-handling', 'Error Handling', this.testErrorHandling.bind(this));
                this.addTest('connection-monitoring', 'Connection Monitoring', this.testConnectionMonitoring.bind(this));
                this.addTest('graceful-degradation', 'Graceful Degradation', this.testGracefulDegradation.bind(this));

                // Property-Based Tests
                this.addTest('financial-calculations', 'Financial Calculations', this.testFinancialCalculations.bind(this));
                this.addTest('data-consistency', 'Data Consistency', this.testDataConsistency.bind(this));
                this.addTest('performance-thresholds', 'Performance Thresholds', this.testPerformanceThresholds.bind(this));

                this.results.total = this.tests.length;
                this.updateStats();
            }
            addTest(id, name, testFunction) {
                this.tests.push({ id, name, testFunction, status: 'pending' });
            }

            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = document.createElement('div');
                logEntry.style.marginBottom = '5px';
                logEntry.style.padding = '5px';
                logEntry.style.borderRadius = '4px';
                
                switch(type) {
                    case 'success':
                        logEntry.style.backgroundColor = '#e8f5e8';
                        logEntry.style.color = '#2e7d32';
                        break;
                    case 'error':
                        logEntry.style.backgroundColor = '#ffebee';
                        logEntry.style.color = '#c62828';
                        break;
                    case 'warning':
                        logEntry.style.backgroundColor = '#fff3e0';
                        logEntry.style.color = '#ef6c00';
                        break;
                    default:
                        logEntry.style.backgroundColor = '#f5f5f5';
                        logEntry.style.color = '#333';
                }
                
                logEntry.innerHTML = `<strong>[${timestamp}]</strong> ${message}`;
                this.logElement.appendChild(logEntry);
                this.logElement.scrollTop = this.logElement.scrollHeight;
            }

            updateTestStatus(testId, status, message = '') {
                const testElement = document.querySelector(`[data-test="${testId}"]`);
                const indicator = testElement.querySelector('.status-indicator');
                
                testElement.className = `test-item ${status}`;
                indicator.className = `status-indicator status-${status}`;
                
                if (message) {
                    let messageElement = testElement.querySelector('.test-message');
                    if (!messageElement) {
                        messageElement = document.createElement('div');
                        messageElement.className = 'test-message';
                        messageElement.style.fontSize = '12px';
                        messageElement.style.marginTop = '5px';
                        testElement.appendChild(messageElement);
                    }
                    messageElement.textContent = message;
                }
            }
            updateStats() {
                document.getElementById('totalTests').textContent = this.results.total;
                document.getElementById('passedTests').textContent = this.results.passed;
                document.getElementById('failedTests').textContent = this.results.failed;
                
                const successRate = this.results.total > 0 ? 
                    Math.round((this.results.passed / this.results.total) * 100) : 0;
                document.getElementById('successRate').textContent = `${successRate}%`;
                
                const progress = this.results.total > 0 ? 
                    ((this.results.passed + this.results.failed) / this.results.total) * 100 : 0;
                document.getElementById('overallProgress').style.width = `${progress}%`;
            }

            async runAllTests() {
                this.log('üöÄ Starting comprehensive dashboard test suite...', 'info');
                this.results.passed = 0;
                this.results.failed = 0;
                
                for (const test of this.tests) {
                    try {
                        this.log(`Running ${test.name}...`, 'info');
                        this.updateTestStatus(test.id, 'running');
                        
                        const result = await test.testFunction();
                        
                        if (result.success) {
                            this.results.passed++;
                            this.updateTestStatus(test.id, 'passed', result.message);
                            this.log(`‚úÖ ${test.name}: ${result.message}`, 'success');
                        } else {
                            this.results.failed++;
                            this.updateTestStatus(test.id, 'failed', result.message);
                            this.log(`‚ùå ${test.name}: ${result.message}`, 'error');
                        }
                    } catch (error) {
                        this.results.failed++;
                        this.updateTestStatus(test.id, 'failed', error.message);
                        this.log(`‚ùå ${test.name}: ${error.message}`, 'error');
                    }
                    
                    this.updateStats();
                    await new Promise(resolve => setTimeout(resolve, 100)); // Small delay for UI updates
                }
                
                this.log(`üèÅ Test suite completed. ${this.results.passed}/${this.results.total} tests passed.`, 
                    this.results.failed === 0 ? 'success' : 'warning');
            }
            // Test Implementations
            async testDashboardSetup() {
                try {
                    if (typeof DashboardController === 'undefined') {
                        return { success: false, message: 'DashboardController not loaded' };
                    }
                    
                    const controller = new DashboardController('test-container', {});
                    await controller.initialize();
                    
                    return { success: true, message: 'Dashboard initialized successfully' };
                } catch (error) {
                    return { success: false, message: `Setup failed: ${error.message}` };
                }
            }

            async testWidgetManagement() {
                try {
                    if (typeof WidgetManager === 'undefined') {
                        return { success: false, message: 'WidgetManager not loaded' };
                    }
                    
                    const widgetManager = new WidgetManager();
                    const widget = await widgetManager.createWidget('kpi', {
                        title: 'Test KPI',
                        position: { x: 0, y: 0 },
                        size: { width: 300, height: 200 }
                    });
                    
                    return { success: true, message: 'Widget management working correctly' };
                } catch (error) {
                    return { success: false, message: `Widget test failed: ${error.message}` };
                }
            }

            async testAnalyticsEngine() {
                try {
                    if (typeof AnalyticsEngine === 'undefined') {
                        return { success: false, message: 'AnalyticsEngine not loaded' };
                    }
                    
                    const engine = new AnalyticsEngine();
                    const testData = {
                        members: [
                            { id: 1, joinDate: '2024-01-01', transactions: 10, totalAmount: 1000000 },
                            { id: 2, joinDate: '2024-02-01', transactions: 5, totalAmount: 500000 }
                        ]
                    };
                    
                    const kpis = await engine.calculateKPIs(testData);
                    
                    if (kpis && kpis.memberCount === 2) {
                        return { success: true, message: 'Analytics calculations verified' };
                    } else {
                        return { success: false, message: 'KPI calculations incorrect' };
                    }
                } catch (error) {
                    return { success: false, message: `Analytics test failed: ${error.message}` };
                }
            }
            async testChartRendering() {
                try {
                    if (typeof ChartRenderer === 'undefined') {
                        return { success: false, message: 'ChartRenderer not loaded' };
                    }
                    
                    const renderer = new ChartRenderer();
                    const testCanvas = document.createElement('canvas');
                    testCanvas.width = 400;
                    testCanvas.height = 300;
                    
                    const chart = await renderer.renderChart('line', {
                        labels: ['Jan', 'Feb', 'Mar'],
                        datasets: [{
                            label: 'Test Data',
                            data: [10, 20, 30]
                        }]
                    }, { canvas: testCanvas });
                    
                    return { success: true, message: 'Chart rendering functional' };
                } catch (error) {
                    return { success: false, message: `Chart test failed: ${error.message}` };
                }
            }

            async testMemberAnalytics() {
                try {
                    if (typeof MemberAnalytics === 'undefined') {
                        return { success: false, message: 'MemberAnalytics not loaded' };
                    }
                    
                    const analytics = new MemberAnalytics();
                    const testMembers = [
                        { id: 1, transactions: 15, lastActivity: '2024-12-01' },
                        { id: 2, transactions: 3, lastActivity: '2024-11-01' }
                    ];
                    
                    const segmentation = analytics.segmentMembers(testMembers);
                    
                    if (segmentation && segmentation.active && segmentation.dormant) {
                        return { success: true, message: 'Member segmentation working' };
                    } else {
                        return { success: false, message: 'Segmentation logic failed' };
                    }
                } catch (error) {
                    return { success: false, message: `Member analytics failed: ${error.message}` };
                }
            }

            async testDataAggregation() {
                try {
                    if (typeof DataAggregator === 'undefined') {
                        return { success: false, message: 'DataAggregator not loaded' };
                    }
                    
                    const aggregator = new DataAggregator();
                    const testData = [
                        { date: '2024-01-01', amount: 100000, category: 'savings' },
                        { date: '2024-01-02', amount: 150000, category: 'savings' },
                        { date: '2024-01-01', amount: 200000, category: 'loans' }
                    ];
                    
                    const aggregated = aggregator.aggregateByCategory(testData);
                    
                    if (aggregated.savings === 250000 && aggregated.loans === 200000) {
                        return { success: true, message: 'Data aggregation accurate' };
                    } else {
                        return { success: false, message: 'Aggregation calculations incorrect' };
                    }
                } catch (error) {
                    return { success: false, message: `Aggregation test failed: ${error.message}` };
                }
            }
            async testStatisticalAnalysis() {
                try {
                    if (typeof StatisticalAnalyzer === 'undefined') {
                        return { success: false, message: 'StatisticalAnalyzer not loaded' };
                    }
                    
                    const analyzer = new StatisticalAnalyzer();
                    const x = [1, 2, 3, 4, 5];
                    const y = [2, 4, 6, 8, 10];
                    
                    const correlation = analyzer.calculateCorrelation(x, y);
                    
                    if (Math.abs(correlation - 1.0) < 0.01) {
                        return { success: true, message: 'Statistical calculations verified' };
                    } else {
                        return { success: false, message: `Correlation calculation incorrect: ${correlation}` };
                    }
                } catch (error) {
                    return { success: false, message: `Statistical test failed: ${error.message}` };
                }
            }

            async testAnomalyDetection() {
                try {
                    if (typeof AnomalyDetector === 'undefined') {
                        return { success: false, message: 'AnomalyDetector not loaded' };
                    }
                    
                    const detector = new AnomalyDetector();
                    const normalData = [100, 105, 98, 102, 99, 101, 103];
                    const dataWithAnomaly = [...normalData, 200]; // Clear anomaly
                    
                    const anomalies = detector.detectAnomalies(dataWithAnomaly);
                    
                    if (anomalies.length > 0 && anomalies.includes(200)) {
                        return { success: true, message: 'Anomaly detection working' };
                    } else {
                        return { success: false, message: 'Failed to detect anomaly' };
                    }
                } catch (error) {
                    return { success: false, message: `Anomaly test failed: ${error.message}` };
                }
            }

            async testResponsiveLayout() {
                try {
                    if (typeof ResponsiveLayoutManager === 'undefined') {
                        return { success: false, message: 'ResponsiveLayoutManager not loaded' };
                    }
                    
                    const layoutManager = new ResponsiveLayoutManager();
                    
                    // Test mobile layout
                    const mobileLayout = layoutManager.getLayoutForViewport(375, 667);
                    
                    if (mobileLayout && mobileLayout.columns <= 2) {
                        return { success: true, message: 'Responsive layout adapts correctly' };
                    } else {
                        return { success: false, message: 'Layout not responsive to mobile' };
                    }
                } catch (error) {
                    return { success: false, message: `Responsive test failed: ${error.message}` };
                }
            }
            async testDashboardCustomization() {
                try {
                    if (typeof DashboardCustomizer === 'undefined') {
                        return { success: false, message: 'DashboardCustomizer not loaded' };
                    }
                    
                    const customizer = new DashboardCustomizer();
                    const layout = [
                        { id: 'widget1', x: 0, y: 0, width: 4, height: 2 },
                        { id: 'widget2', x: 4, y: 0, width: 4, height: 2 }
                    ];
                    
                    customizer.saveLayout(layout);
                    const savedLayout = customizer.getLayout();
                    
                    if (savedLayout && savedLayout.length === 2) {
                        return { success: true, message: 'Dashboard customization functional' };
                    } else {
                        return { success: false, message: 'Layout save/load failed' };
                    }
                } catch (error) {
                    return { success: false, message: `Customization test failed: ${error.message}` };
                }
            }

            async testRoleBasedAccess() {
                try {
                    if (typeof RoleBasedAccessControl === 'undefined') {
                        return { success: false, message: 'RoleBasedAccessControl not loaded' };
                    }
                    
                    const rbac = new RoleBasedAccessControl();
                    
                    // Test viewer role restrictions
                    const viewerPermissions = rbac.getPermissions('viewer');
                    const adminPermissions = rbac.getPermissions('admin');
                    
                    if (viewerPermissions.canEdit === false && adminPermissions.canEdit === true) {
                        return { success: true, message: 'Role-based access control working' };
                    } else {
                        return { success: false, message: 'Permission system not working correctly' };
                    }
                } catch (error) {
                    return { success: false, message: `RBAC test failed: ${error.message}` };
                }
            }

            async testUserPreferences() {
                try {
                    if (typeof UserPreferencesManager === 'undefined') {
                        return { success: false, message: 'UserPreferencesManager not loaded' };
                    }
                    
                    const prefManager = new UserPreferencesManager();
                    const testPrefs = {
                        theme: 'dark',
                        language: 'id',
                        refreshInterval: 300000
                    };
                    
                    prefManager.savePreferences(testPrefs);
                    const savedPrefs = prefManager.getPreferences();
                    
                    if (savedPrefs.theme === 'dark' && savedPrefs.language === 'id') {
                        return { success: true, message: 'User preferences management working' };
                    } else {
                        return { success: false, message: 'Preferences not saved correctly' };
                    }
                } catch (error) {
                    return { success: false, message: `Preferences test failed: ${error.message}` };
                }
            }
            async testLoadingPerformance() {
                try {
                    const startTime = performance.now();
                    
                    // Simulate dashboard loading
                    if (typeof DashboardController !== 'undefined') {
                        const controller = new DashboardController('test-container', {});
                        await controller.initialize();
                    }
                    
                    const loadTime = performance.now() - startTime;
                    
                    if (loadTime < 3000) { // 3 second requirement
                        return { success: true, message: `Load time: ${Math.round(loadTime)}ms (< 3s requirement)` };
                    } else {
                        return { success: false, message: `Load time: ${Math.round(loadTime)}ms (exceeds 3s requirement)` };
                    }
                } catch (error) {
                    return { success: false, message: `Performance test failed: ${error.message}` };
                }
            }

            async testCachingSystem() {
                try {
                    if (typeof CacheManager === 'undefined') {
                        return { success: false, message: 'CacheManager not loaded' };
                    }
                    
                    const cache = new CacheManager();
                    const testData = { key: 'test', value: 'cached data' };
                    
                    cache.set('testKey', testData, 60000); // 1 minute TTL
                    const cachedData = cache.get('testKey');
                    
                    if (cachedData && cachedData.value === 'cached data') {
                        return { success: true, message: 'Caching system functional' };
                    } else {
                        return { success: false, message: 'Cache set/get failed' };
                    }
                } catch (error) {
                    return { success: false, message: `Caching test failed: ${error.message}` };
                }
            }

            async testAutoRefresh() {
                try {
                    if (typeof AutoRefreshManager === 'undefined') {
                        return { success: false, message: 'AutoRefreshManager not loaded' };
                    }
                    
                    const refreshManager = new AutoRefreshManager();
                    let refreshCount = 0;
                    
                    const callback = () => { refreshCount++; };
                    refreshManager.setRefreshInterval(callback, 100); // 100ms for testing
                    
                    // Wait for at least one refresh
                    await new Promise(resolve => setTimeout(resolve, 150));
                    refreshManager.clearRefreshInterval();
                    
                    if (refreshCount > 0) {
                        return { success: true, message: 'Auto-refresh mechanism working' };
                    } else {
                        return { success: false, message: 'Auto-refresh not triggered' };
                    }
                } catch (error) {
                    return { success: false, message: `Auto-refresh test failed: ${error.message}` };
                }
            }
            async testMobileOptimization() {
                try {
                    if (typeof MobileOptimizer === 'undefined') {
                        return { success: false, message: 'MobileOptimizer not loaded' };
                    }
                    
                    const optimizer = new MobileOptimizer();
                    
                    // Test mobile detection
                    const isMobile = optimizer.detectMobileDevice();
                    const optimizations = optimizer.getOptimizations();
                    
                    if (optimizations && typeof optimizations.dataCompression === 'boolean') {
                        return { success: true, message: 'Mobile optimization features available' };
                    } else {
                        return { success: false, message: 'Mobile optimizations not configured' };
                    }
                } catch (error) {
                    return { success: false, message: `Mobile test failed: ${error.message}` };
                }
            }

            async testExportManager() {
                try {
                    if (typeof ExportManager === 'undefined') {
                        return { success: false, message: 'ExportManager not loaded' };
                    }
                    
                    const exportManager = new ExportManager();
                    const testData = {
                        title: 'Test Report',
                        data: [
                            { metric: 'Total Members', value: 1000 },
                            { metric: 'Active Members', value: 850 }
                        ]
                    };
                    
                    // Test PDF export capability
                    const pdfSupported = exportManager.supportsPDF();
                    const excelSupported = exportManager.supportsExcel();
                    
                    if (pdfSupported && excelSupported) {
                        return { success: true, message: 'Export formats supported (PDF, Excel)' };
                    } else {
                        return { success: false, message: 'Export formats not fully supported' };
                    }
                } catch (error) {
                    return { success: false, message: `Export test failed: ${error.message}` };
                }
            }

            async testReportBuilder() {
                try {
                    if (typeof ReportBuilder === 'undefined') {
                        return { success: false, message: 'ReportBuilder not loaded' };
                    }
                    
                    const reportBuilder = new ReportBuilder();
                    const reportConfig = {
                        title: 'Monthly KPI Report',
                        dateRange: { start: '2024-01-01', end: '2024-01-31' },
                        metrics: ['memberCount', 'transactionVolume', 'financialHealth']
                    };
                    
                    const report = reportBuilder.buildReport(reportConfig);
                    
                    if (report && report.title === 'Monthly KPI Report') {
                        return { success: true, message: 'Report builder functional' };
                    } else {
                        return { success: false, message: 'Report generation failed' };
                    }
                } catch (error) {
                    return { success: false, message: `Report builder test failed: ${error.message}` };
                }
            }
            async testFormatPreservation() {
                try {
                    // Test data format preservation in exports
                    const testData = {
                        numbers: [1000000, 2500000.50, 999.99],
                        dates: ['2024-01-01', '2024-12-31'],
                        percentages: [0.15, 0.8567, 1.0]
                    };
                    
                    // Simulate format preservation check
                    const preserved = testData.numbers.every(num => typeof num === 'number') &&
                                    testData.dates.every(date => /^\d{4}-\d{2}-\d{2}$/.test(date)) &&
                                    testData.percentages.every(pct => pct >= 0 && pct <= 1);
                    
                    if (preserved) {
                        return { success: true, message: 'Data format preservation verified' };
                    } else {
                        return { success: false, message: 'Data format not preserved correctly' };
                    }
                } catch (error) {
                    return { success: false, message: `Format preservation test failed: ${error.message}` };
                }
            }

            async testErrorHandling() {
                try {
                    if (typeof ErrorHandler === 'undefined') {
                        return { success: false, message: 'ErrorHandler not loaded' };
                    }
                    
                    const errorHandler = new ErrorHandler();
                    let errorCaught = false;
                    
                    errorHandler.onError((error) => {
                        errorCaught = true;
                    });
                    
                    // Trigger a test error
                    errorHandler.handleError(new Error('Test error'));
                    
                    if (errorCaught) {
                        return { success: true, message: 'Error handling system working' };
                    } else {
                        return { success: false, message: 'Error handler not triggered' };
                    }
                } catch (error) {
                    return { success: false, message: `Error handling test failed: ${error.message}` };
                }
            }

            async testConnectionMonitoring() {
                try {
                    if (typeof ConnectionMonitor === 'undefined') {
                        return { success: false, message: 'ConnectionMonitor not loaded' };
                    }
                    
                    const monitor = new ConnectionMonitor();
                    
                    // Test connection status detection
                    const isOnline = monitor.isOnline();
                    
                    if (typeof isOnline === 'boolean') {
                        return { success: true, message: `Connection monitoring active (Status: ${isOnline ? 'Online' : 'Offline'})` };
                    } else {
                        return { success: false, message: 'Connection status detection failed' };
                    }
                } catch (error) {
                    return { success: false, message: `Connection monitoring test failed: ${error.message}` };
                }
            }
            async testGracefulDegradation() {
                try {
                    // Test graceful degradation with cached data
                    if (typeof CacheManager !== 'undefined') {
                        const cache = new CacheManager();
                        
                        // Set some cached data
                        cache.set('fallbackData', { 
                            memberCount: 1000, 
                            lastUpdate: new Date().toISOString() 
                        });
                        
                        // Simulate network failure and fallback to cache
                        const fallbackData = cache.get('fallbackData');
                        
                        if (fallbackData && fallbackData.memberCount === 1000) {
                            return { success: true, message: 'Graceful degradation with cached data working' };
                        } else {
                            return { success: false, message: 'Fallback to cached data failed' };
                        }
                    } else {
                        return { success: false, message: 'Cache system not available for degradation' };
                    }
                } catch (error) {
                    return { success: false, message: `Graceful degradation test failed: ${error.message}` };
                }
            }

            async testFinancialCalculations() {
                try {
                    // Property-based test for financial calculations
                    if (typeof AnalyticsEngine !== 'undefined') {
                        const engine = new AnalyticsEngine();
                        
                        // Test financial health score calculation
                        const testFinancials = {
                            totalAssets: 10000000,
                            totalLiabilities: 6000000,
                            totalEquity: 4000000,
                            monthlyRevenue: 500000,
                            monthlyExpenses: 400000
                        };
                        
                        const healthScore = engine.calculateFinancialHealthScore(testFinancials);
                        
                        // Health score should be between 0-100
                        if (healthScore >= 0 && healthScore <= 100) {
                            return { success: true, message: `Financial calculations accurate (Health Score: ${healthScore})` };
                        } else {
                            return { success: false, message: `Invalid health score: ${healthScore}` };
                        }
                    } else {
                        return { success: false, message: 'AnalyticsEngine not available for financial tests' };
                    }
                } catch (error) {
                    return { success: false, message: `Financial calculations test failed: ${error.message}` };
                }
            }

            async testDataConsistency() {
                try {
                    // Test data consistency across operations
                    const testTransactions = [
                        { id: 1, amount: 100000, type: 'deposit' },
                        { id: 2, amount: 50000, type: 'withdrawal' },
                        { id: 3, amount: 75000, type: 'deposit' }
                    ];
                    
                    const totalDeposits = testTransactions
                        .filter(t => t.type === 'deposit')
                        .reduce((sum, t) => sum + t.amount, 0);
                    
                    const totalWithdrawals = testTransactions
                        .filter(t => t.type === 'withdrawal')
                        .reduce((sum, t) => sum + t.amount, 0);
                    
                    const netBalance = totalDeposits - totalWithdrawals;
                    
                    if (netBalance === 125000) { // 175000 - 50000
                        return { success: true, message: 'Data consistency maintained across operations' };
                    } else {
                        return { success: false, message: `Inconsistent calculations: ${netBalance}` };
                    }
                } catch (error) {
                    return { success: false, message: `Data consistency test failed: ${error.message}` };
                }
            }
            async testPerformanceThresholds() {
                try {
                    // Test performance thresholds compliance
                    const performanceTests = [];
                    
                    // Test 1: Widget rendering time
                    const startRender = performance.now();
                    // Simulate widget rendering
                    await new Promise(resolve => setTimeout(resolve, 50));
                    const renderTime = performance.now() - startRender;
                    performanceTests.push({ test: 'Widget Render', time: renderTime, threshold: 100 });
                    
                    // Test 2: Data processing time
                    const startProcess = performance.now();
                    const largeDataset = Array.from({ length: 1000 }, (_, i) => ({ id: i, value: Math.random() * 1000 }));
                    const processed = largeDataset.map(item => ({ ...item, processed: true }));
                    const processTime = performance.now() - startProcess;
                    performanceTests.push({ test: 'Data Processing', time: processTime, threshold: 200 });
                    
                    const allPassed = performanceTests.every(test => test.time < test.threshold);
                    
                    if (allPassed) {
                        const summary = performanceTests.map(t => `${t.test}: ${Math.round(t.time)}ms`).join(', ');
                        return { success: true, message: `Performance thresholds met (${summary})` };
                    } else {
                        const failed = performanceTests.filter(t => t.time >= t.threshold);
                        return { success: false, message: `Performance threshold exceeded: ${failed[0].test}` };
                    }
                } catch (error) {
                    return { success: false, message: `Performance threshold test failed: ${error.message}` };
                }
            }
        }

        // Initialize and run tests
        document.addEventListener('DOMContentLoaded', () => {
            const tester = new FinalCheckpointTester();
            
            document.getElementById('runAllTests').addEventListener('click', () => {
                tester.runAllTests();
            });
            
            // Auto-run tests after 2 seconds
            setTimeout(() => {
                tester.runAllTests();
            }, 2000);
        });
    </script>
</body>
</html>