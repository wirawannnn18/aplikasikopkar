<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Task 6.3: Caching and Performance Optimization Test</title>
    <link rel="stylesheet" href="css/lazy-loading.css">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
            text-align: center;
        }
        
        .test-section {
            background: white;
            padding: 25px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .metric {
            text-align: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }
        
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }
        
        .metric-label {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .widget-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .test-widget {
            height: 200px;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            background: white;
        }
        
        .log {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
            margin-top: 20px;
        }
        
        .log-entry {
            margin-bottom: 5px;
            padding: 2px 0;
        }
        
        .log-entry.info { color: #007bff; }
        .log-entry.success { color: #28a745; }
        .log-entry.warning { color: #ffc107; }
        .log-entry.error { color: #dc3545; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Task 6.3: Caching and Performance Optimization</h1>
        <p>Interactive testing interface for cache management, progressive loading, and lazy widget loading</p>
        <p><strong>Feature:</strong> dashboard-analytics-kpi | <strong>Validates:</strong> Requirements 6.1, 6.5, 8.1</p>
    </div>

    <!-- Cache Manager Test -->
    <div class="test-section">
        <h2>Cache Manager Test</h2>
        <p>Test intelligent data caching with TTL, memory management, and performance optimization.</p>
        
        <div class="controls">
            <button onclick="testCacheBasicOperations()">Test Basic Operations</button>
            <button onclick="testCacheTTL()">Test TTL Expiration</button>
            <button onclick="testCacheMemoryManagement()">Test Memory Management</button>
            <button onclick="testCachePatterns()">Test Pattern Invalidation</button>
            <button onclick="clearCache()">Clear Cache</button>
        </div>
        
        <div class="metrics" id="cacheMetrics">
            <div class="metric">
                <div class="metric-value" id="cacheSize">0</div>
                <div class="metric-label">Cache Size</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="hitRate">0%</div>
                <div class="metric-label">Hit Rate</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="memoryUsage">0KB</div>
                <div class="metric-label">Memory Usage</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="evictions">0</div>
                <div class="metric-label">Evictions</div>
            </div>
        </div>
    </div>

    <script src="js/dashboard/CacheManager.js"></script>
    <script src="js/dashboard/ProgressiveLoader.js"></script>
    <script src="js/dashboard/LazyWidgetLoader.js"></script>
    <script>
        // Initialize components
        const cacheManager = new CacheManager({
            defaultTTL: 10000, // 10 seconds for testing
            maxCacheSize: 50,
            maxMemoryUsage: 1024 * 1024 // 1MB
        });
        
        const progressiveLoader = new ProgressiveLoader({
            chunkSize: 10,
            loadDelay: 100
        });
        
        const lazyLoader = new LazyWidgetLoader({
            intersectionThreshold: 0.1,
            loadDelay: 200
        });
        
        // Logging
        function log(message, type = 'info') {
            const logDiv = document.getElementById('testLog') || createLogDiv();
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
        }
        
        function createLogDiv() {
            const logDiv = document.createElement('div');
            logDiv.id = 'testLog';
            logDiv.className = 'log';
            document.body.appendChild(logDiv);
            return logDiv;
        }
        
        // Update cache metrics
        function updateCacheMetrics() {
            const stats = cacheManager.getStats();
            document.getElementById('cacheSize').textContent = stats.size;
            document.getElementById('hitRate').textContent = stats.hitRate;
            document.getElementById('memoryUsage').textContent = Math.round(stats.memoryUsage / 1024) + 'KB';
            document.getElementById('evictions').textContent = stats.evictions;
        }
        
        // Cache Manager Tests
        async function testCacheBasicOperations() {
            log('Testing basic cache operations...', 'info');
            
            // Set some test data
            const testData = { message: 'Hello Cache!', timestamp: Date.now() };
            cacheManager.set('test-key', testData);
            log('✓ Data cached with key "test-key"', 'success');
            
            // Get cached data
            const retrieved = cacheManager.get('test-key');
            if (retrieved && retrieved.message === testData.message) {
                log('✓ Data retrieved successfully from cache', 'success');
            } else {
                log('✗ Failed to retrieve data from cache', 'error');
            }
            
            // Test cache miss
            const missing = cacheManager.get('non-existent-key');
            if (missing === null) {
                log('✓ Cache miss handled correctly', 'success');
            } else {
                log('✗ Cache miss not handled correctly', 'error');
            }
            
            updateCacheMetrics();
        }
        
        async function testCacheTTL() {
            log('Testing TTL expiration...', 'info');
            
            // Set data with short TTL
            cacheManager.set('ttl-test', { data: 'expires soon' }, 2000); // 2 seconds
            log('✓ Data cached with 2-second TTL', 'success');
            
            // Immediate retrieval should work
            let data = cacheManager.get('ttl-test');
            if (data) {
                log('✓ Data retrieved immediately', 'success');
            }
            
            // Wait for expiration
            setTimeout(() => {
                const expiredData = cacheManager.get('ttl-test');
                if (expiredData === null) {
                    log('✓ Data expired correctly after TTL', 'success');
                } else {
                    log('✗ Data did not expire after TTL', 'error');
                }
                updateCacheMetrics();
            }, 2500);
        }
        
        async function testCacheMemoryManagement() {
            log('Testing memory management...', 'info');
            
            // Fill cache with large data
            for (let i = 0; i < 60; i++) {
                const largeData = new Array(1000).fill(`data-${i}`);
                cacheManager.set(`large-${i}`, largeData);
            }
            
            log('✓ Added 60 large items to cache', 'success');
            
            setTimeout(() => {
                const stats = cacheManager.getStats();
                if (stats.evictions > 0) {
                    log(`✓ Memory management triggered ${stats.evictions} evictions`, 'success');
                } else {
                    log('! No evictions occurred (cache may not be full)', 'warning');
                }
                updateCacheMetrics();
            }, 1000);
        }
        
        async function testCachePatterns() {
            log('Testing pattern invalidation...', 'info');
            
            // Add data with patterns
            cacheManager.set('user:123:profile', { name: 'John' });
            cacheManager.set('user:456:profile', { name: 'Jane' });
            cacheManager.set('user:123:settings', { theme: 'dark' });
            cacheManager.set('product:789', { name: 'Widget' });
            
            log('✓ Added test data with patterns', 'success');
            
            // Invalidate user patterns
            const invalidated = cacheManager.invalidatePattern(/^user:/);
            log(`✓ Invalidated ${invalidated} items matching user pattern`, 'success');
            
            // Check remaining data
            const remaining = cacheManager.get('product:789');
            if (remaining) {
                log('✓ Non-matching data preserved', 'success');
            } else {
                log('✗ Non-matching data was incorrectly removed', 'error');
            }
            
            updateCacheMetrics();
        }
        
        function clearCache() {
            cacheManager.clear();
            log('✓ Cache cleared', 'success');
            updateCacheMetrics();
        }
        
        // Initialize
        updateCacheMetrics();
        log('Cache Manager Test Interface Initialized', 'info');
    </script>
</body>
</html>
    <!-- Progressive Loader Test -->
    <div class="test-section">
        <h2>Progressive Loader Test</h2>
        <p>Test progressive loading of large datasets with chunking and performance monitoring.</p>
        
        <div class="controls">
            <button onclick="testProgressiveLoading()">Test Progressive Loading</button>
            <button onclick="testVirtualScrolling()">Test Virtual Scrolling</button>
            <button onclick="testLazyDataLoader()">Test Lazy Data Loader</button>
            <button onclick="clearProgressiveTests()">Clear Tests</button>
        </div>
        
        <div class="metrics" id="progressiveMetrics">
            <div class="metric">
                <div class="metric-value" id="totalLoads">0</div>
                <div class="metric-label">Total Loads</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="successRate">0%</div>
                <div class="metric-label">Success Rate</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="avgLoadTime">0ms</div>
                <div class="metric-label">Avg Load Time</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="recordsLoaded">0</div>
                <div class="metric-label">Records Loaded</div>
            </div>
        </div>
        
        <div id="progressiveResults"></div>
    </div>

    <!-- Lazy Widget Loader Test -->
    <div class="test-section">
        <h2>Lazy Widget Loader Test</h2>
        <p>Test lazy loading of dashboard widgets with intersection observer and performance tracking.</p>
        
        <div class="controls">
            <button onclick="createLazyWidgets()">Create Lazy Widgets</button>
            <button onclick="preloadHighPriority()">Preload High Priority</button>
            <button onclick="simulateScrolling()">Simulate Scrolling</button>
            <button onclick="clearWidgets()">Clear Widgets</button>
        </div>
        
        <div class="metrics" id="widgetMetrics">
            <div class="metric">
                <div class="metric-value" id="totalWidgets">0</div>
                <div class="metric-label">Total Widgets</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="loadedWidgets">0</div>
                <div class="metric-label">Loaded Widgets</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="widgetSuccessRate">0%</div>
                <div class="metric-label">Success Rate</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="avgWidgetLoadTime">0ms</div>
                <div class="metric-label">Avg Load Time</div>
            </div>
        </div>
        
        <div class="widget-grid" id="widgetContainer"></div>
    </div>

    <!-- Test Log -->
    <div class="test-section">
        <h2>Test Log</h2>
        <div id="testLog" class="log"></div>
        <button onclick="clearLog()" style="margin-top: 10px;">Clear Log</button>
    </div>

    <script>
        // Progressive Loader Tests
        async function testProgressiveLoading() {
            log('Testing progressive loading...', 'info');
            
            // Mock data source
            const mockDataSource = async ({ offset, limit }) => {
                // Simulate network delay
                await new Promise(resolve => setTimeout(resolve, Math.random() * 200 + 100));
                
                const data = [];
                for (let i = offset; i < offset + limit; i++) {
                    data.push({
                        id: i,
                        name: `Record ${i}`,
                        value: Math.random() * 1000,
                        timestamp: new Date().toISOString()
                    });
                }
                return data;
            };
            
            const totalRecords = 100;
            const resultsDiv = document.getElementById('progressiveResults');
            resultsDiv.innerHTML = '<div class="progressive-loader"><div class="progress-bar" id="progressBar"></div><div class="progress-info" id="progressInfo">0%</div></div>';
            
            try {
                const result = await progressiveLoader.loadData({
                    dataSource: mockDataSource,
                    totalRecords,
                    onProgress: (progress) => {
                        const progressBar = document.getElementById('progressBar');
                        const progressInfo = document.getElementById('progressInfo');
                        if (progressBar && progressInfo) {
                            progressBar.style.width = progress.progress + '%';
                            progressInfo.textContent = `${progress.progress}% (${progress.loadedRecords}/${progress.totalRecords})`;
                        }
                        log(`Progress: ${progress.progress}% - Loaded ${progress.loadedRecords} records`, 'info');
                    },
                    onChunkLoaded: (chunk) => {
                        log(`Chunk ${chunk.chunkIndex} loaded with ${chunk.chunkData.length} records`, 'success');
                    },
                    onComplete: (result) => {
                        log(`Progressive loading completed: ${result.totalRecords} records in ${result.loadTime}ms`, 'success');
                    }
                });
                
                resultsDiv.innerHTML += `<div style="margin-top: 15px;"><strong>Results:</strong> Loaded ${result.totalRecords} records in ${result.loadTime}ms (${result.chunks} chunks)</div>`;
                
            } catch (error) {
                log(`Progressive loading failed: ${error.message}`, 'error');
            }
            
            updateProgressiveMetrics();
        }
        
        async function testVirtualScrolling() {
            log('Testing virtual scrolling...', 'info');
            
            const mockDataSource = async ({ offset, limit }) => {
                await new Promise(resolve => setTimeout(resolve, 50));
                const data = [];
                for (let i = offset; i < offset + limit; i++) {
                    data.push(`Virtual Item ${i}`);
                }
                return data;
            };
            
            const virtualScroller = progressiveLoader.createVirtualScrollLoader({
                totalItems: 1000,
                itemHeight: 40,
                containerHeight: 400,
                dataSource: mockDataSource
            });
            
            const resultsDiv = document.getElementById('progressiveResults');
            resultsDiv.innerHTML = `
                <div class="virtual-scroll-container" style="height: 300px; border: 1px solid #ddd; margin-top: 15px;">
                    <div class="virtual-scroll-content" id="virtualContent"></div>
                </div>
            `;
            
            // Simulate scrolling
            let scrollTop = 0;
            const updateVirtualView = async () => {
                const visibleItems = await virtualScroller.getVisibleItems(scrollTop);
                const content = document.getElementById('virtualContent');
                if (content) {
                    content.innerHTML = visibleItems.items.map((item, index) => 
                        `<div class="virtual-item" style="top: ${(visibleItems.startIndex + index) * 40}px; height: 40px;">${item}</div>`
                    ).join('');
                }
            };
            
            await updateVirtualView();
            log('✓ Virtual scrolling initialized with 1000 items', 'success');
            
            // Simulate scroll events
            setTimeout(async () => {
                scrollTop = 2000;
                await updateVirtualView();
                log('✓ Virtual scroll updated to position 2000px', 'success');
            }, 1000);
        }
        
        async function testLazyDataLoader() {
            log('Testing lazy data loader...', 'info');
            
            const lazyLoader = progressiveLoader.createLazyLoader({
                dataSource: async () => {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    return { message: 'Lazy loaded data!', timestamp: Date.now() };
                },
                cacheManager: cacheManager,
                cacheKey: 'lazy-test-data'
            });
            
            // First call - should load data
            const start1 = Date.now();
            const data1 = await lazyLoader();
            const time1 = Date.now() - start1;
            log(`✓ First call completed in ${time1}ms: ${data1.message}`, 'success');
            
            // Second call - should use cached data
            const start2 = Date.now();
            const data2 = await lazyLoader();
            const time2 = Date.now() - start2;
            log(`✓ Second call completed in ${time2}ms (cached): ${data2.message}`, 'success');
            
            if (time2 < time1 / 2) {
                log('✓ Caching provided significant performance improvement', 'success');
            }
        }
        
        function clearProgressiveTests() {
            document.getElementById('progressiveResults').innerHTML = '';
            log('✓ Progressive test results cleared', 'success');
        }
        
        function updateProgressiveMetrics() {
            const metrics = progressiveLoader.getMetrics();
            document.getElementById('totalLoads').textContent = metrics.totalLoads;
            document.getElementById('successRate').textContent = metrics.successRate;
            document.getElementById('avgLoadTime').textContent = metrics.averageLoadTime + 'ms';
            document.getElementById('recordsLoaded').textContent = metrics.totalRecordsLoaded;
        }
        
        // Lazy Widget Tests
        function createLazyWidgets() {
            log('Creating lazy widgets...', 'info');
            
            const container = document.getElementById('widgetContainer');
            container.innerHTML = '';
            
            const priorities = ['high', 'normal', 'low'];
            
            for (let i = 0; i < 12; i++) {
                const widgetElement = document.createElement('div');
                widgetElement.className = 'test-widget';
                widgetElement.id = `widget-${i}`;
                container.appendChild(widgetElement);
                
                const priority = priorities[i % 3];
                
                lazyLoader.registerWidget({
                    id: `widget-${i}`,
                    element: widgetElement,
                    priority: priority,
                    loader: async () => {
                        // Simulate loading time
                        await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 500));
                        
                        return `
                            <div style="text-align: center; padding: 20px;">
                                <h3>Widget ${i}</h3>
                                <p>Priority: ${priority}</p>
                                <p>Loaded at: ${new Date().toLocaleTimeString()}</p>
                                <div style="background: linear-gradient(45deg, #667eea, #764ba2); height: 60px; border-radius: 4px; margin-top: 10px;"></div>
                            </div>
                        `;
                    },
                    onLoad: ({ widgetId, loadTime }) => {
                        log(`✓ Widget ${widgetId} loaded in ${loadTime}ms`, 'success');
                        updateWidgetMetrics();
                    },
                    onError: ({ widgetId, error }) => {
                        log(`✗ Widget ${widgetId} failed to load: ${error.message}`, 'error');
                        updateWidgetMetrics();
                    }
                });
            }
            
            log(`✓ Created 12 lazy widgets with mixed priorities`, 'success');
            updateWidgetMetrics();
        }
        
        async function preloadHighPriority() {
            log('Preloading high priority widgets...', 'info');
            
            const results = await lazyLoader.preloadByPriority('high');
            const successful = results.filter(r => r.success).length;
            const failed = results.filter(r => !r.success).length;
            
            log(`✓ Preload completed: ${successful} successful, ${failed} failed`, 'success');
            updateWidgetMetrics();
        }
        
        function simulateScrolling() {
            log('Simulating scrolling to trigger lazy loading...', 'info');
            
            const container = document.getElementById('widgetContainer');
            container.scrollIntoView({ behavior: 'smooth' });
            
            // Scroll through the widget container
            let scrollPosition = 0;
            const scrollInterval = setInterval(() => {
                window.scrollTo(0, scrollPosition);
                scrollPosition += 100;
                
                if (scrollPosition > document.body.scrollHeight) {
                    clearInterval(scrollInterval);
                    log('✓ Scrolling simulation completed', 'success');
                }
            }, 200);
        }
        
        function clearWidgets() {
            const container = document.getElementById('widgetContainer');
            container.innerHTML = '';
            
            // Clear all registered widgets
            const widgets = lazyLoader.getWidgetInfo();
            widgets.forEach(widget => {
                lazyLoader.unregisterWidget(widget.id);
            });
            
            log('✓ All widgets cleared', 'success');
            updateWidgetMetrics();
        }
        
        function updateWidgetMetrics() {
            const metrics = lazyLoader.getMetrics();
            document.getElementById('totalWidgets').textContent = metrics.activeWidgets;
            document.getElementById('loadedWidgets').textContent = metrics.loadedWidgets;
            document.getElementById('widgetSuccessRate').textContent = metrics.successRate;
            document.getElementById('avgWidgetLoadTime').textContent = metrics.averageLoadTime + 'ms';
        }
        
        function clearLog() {
            const logDiv = document.getElementById('testLog');
            logDiv.innerHTML = '';
        }
        
        // Initialize metrics
        updateProgressiveMetrics();
        updateWidgetMetrics();
    </script>