<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Integrated Performance Optimization Test</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
    <style>
        .performance-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px;
            padding: 20px;
            margin: 10px 0;
        }
        .metric-badge {
            background: rgba(255,255,255,0.2);
            border-radius: 20px;
            padding: 5px 15px;
            margin: 5px;
            display: inline-block;
        }
        .test-progress {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
        }
        .success-indicator { color: #28a745; }
        .warning-indicator { color: #ffc107; }
        .error-indicator { color: #dc3545; }
    </style>
</head>
<body>
    <div class="container-fluid py-4">
        <div class="row">
            <div class="col-12">
                <h1><i class="bi bi-lightning-charge"></i> Integrated Performance Optimization Test</h1>
                <p class="text-muted">Comprehensive testing of lazy loading and data query optimization working together</p>
            </div>
        </div>

        <!-- Performance Overview -->
        <div class="row">
            <div class="col-md-6">
                <div class="performance-card">
                    <h4><i class="bi bi-hourglass-split"></i> Lazy Loading Performance</h4>
                    <div id="lazyLoadingOverview">
                        <div class="metric-badge">Controllers: <span id="loadedControllers">0</span></div>
                        <div class="metric-badge">Cache Size: <span id="cacheSize">0</span></div>
                        <div class="metric-badge">Avg Load Time: <span id="avgLoadTime">0ms</span></div>
                    </div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="performance-card">
                    <h4><i class="bi bi-database-gear"></i> Query Optimization Performance</h4>
                    <div id="queryOptimizationOverview">
                        <div class="metric-badge">Cache Hit Rate: <span id="cacheHitRate">0%</span></div>
                        <div class="metric-badge">Avg Query Time: <span id="avgQueryTime">0ms</span></div>
                        <div class="metric-badge">Queries Executed: <span id="queriesExecuted">0</span></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Test Controls -->
        <div class="row">
            <div class="col-12">
                <div class="card">
                    <div class="card-header">
                        <h5><i class="bi bi-play-circle"></i> Integrated Performance Tests</h5>
                    </div>
                    <div class="card-body">
                        <div class="btn-group me-2" role="group">
                            <button type="button" class="btn btn-primary" onclick="runFullIntegrationTest()">
                                <i class="bi bi-speedometer"></i> Full Integration Test
                            </button>
                            <button type="button" class="btn btn-success" onclick="runPerformanceBenchmark()">
                                <i class="bi bi-graph-up"></i> Performance Benchmark
                            </button>
                            <button type="button" class="btn btn-info" onclick="runStressTest()">
                                <i class="bi bi-cpu"></i> Stress Test
                            </button>
                        </div>
                        <div class="btn-group" role="group">
                            <button type="button" class="btn btn-warning" onclick="generateLargeDataset()">
                                <i class="bi bi-database-add"></i> Generate Large Dataset
                            </button>
                            <button type="button" class="btn btn-secondary" onclick="clearAllData()">
                                <i class="bi bi-trash"></i> Clear All Data
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Test Progress -->
        <div class="row">
            <div class="col-12">
                <div class="card">
                    <div class="card-header">
                        <h5><i class="bi bi-activity"></i> Test Progress</h5>
                    </div>
                    <div class="card-body">
                        <div id="testProgress" class="test-progress">
                            <div class="text-muted">No tests running. Click a test button to start.</div>
                        </div>
                        <div class="progress" style="height: 20px;">
                            <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%">0%</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Detailed Results -->
        <div class="row">
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header">
                        <h5><i class="bi bi-clipboard-data"></i> Lazy Loading Results</h5>
                    </div>
                    <div class="card-body">
                        <div id="lazyLoadingResults">
                            <div class="text-muted">No results yet</div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header">
                        <h5><i class="bi bi-bar-chart"></i> Query Optimization Results</h5>
                    </div>
                    <div class="card-body">
                        <div id="queryOptimizationResults">
                            <div class="text-muted">No results yet</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Performance Comparison -->
        <div class="row">
            <div class="col-12">
                <div class="card">
                    <div class="card-header">
                        <h5><i class="bi bi-graph-up-arrow"></i> Performance Comparison</h5>
                    </div>
                    <div class="card-body">
                        <canvas id="performanceChart" width="400" height="200"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Load Required Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="js/shared/LazyLoadingManager.js"></script>
    <script src="js/shared/DataQueryOptimizer.js"></script>
    <script src="js/shared/SharedPaymentServices.js"></script>

    <script>
        // Global test variables
        let lazyLoadingManager;
        let dataQueryOptimizer;
        let sharedServices;
        let performanceChart;
        let testResults = {
            lazyLoading: [],
            queryOptimization: [],
            integrated: []
        };

        // Initialize test environment
        async function initializeTestEnvironment() {
            try {
                updateProgress('Initializing test environment...', 10);
                
                // Initialize shared services
                sharedServices = new SharedPaymentServices();
                await sharedServices.initialize();
                
                // Initialize lazy loading manager
                lazyLoadingManager = new LazyLoadingManager();
                
                // Initialize data query optimizer
                dataQueryOptimizer = new DataQueryOptimizer(sharedServices);
                
                updateProgress('Test environment initialized successfully', 20);
                
                // Initialize performance chart
                initializePerformanceChart();
                
                updateProgress('Ready for testing', 100);
                
            } catch (error) {
                updateProgress(`Failed to initialize: ${error.message}`, 0, 'error');
            }
        }

        // Generate large dataset for performance testing
        function generateLargeDataset() {
            updateProgress('Generating large dataset...', 0);
            
            try {
                const anggotaCount = 10000;
                const transactionCount = 50000;
                
                // Generate anggota data
                const anggotaList = [];
                for (let i = 1; i <= anggotaCount; i++) {
                    anggotaList.push({
                        id: `A${String(i).padStart(6, '0')}`,
                        nama: `Anggota Performance Test ${i}`,
                        nik: `NIK${String(i).padStart(8, '0')}`,
                        status: i % 20 === 0 ? 'inactive' : 'active',
                        departemen: `Dept${Math.floor(i / 100) + 1}`,
                        tanggalDaftar: new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000).toISOString()
                    });
                    
                    if (i % 1000 === 0) {
                        updateProgress(`Generated ${i}/${anggotaCount} anggota...`, (i / anggotaCount) * 30);
                    }
                }
                
                // Generate transaction data
                const transactionList = [];
                const modes = ['manual', 'import'];
                const jenis = ['hutang', 'piutang'];
                
                for (let i = 1; i <= transactionCount; i++) {
                    const anggotaIndex = Math.floor(Math.random() * anggotaList.length);
                    const anggota = anggotaList[anggotaIndex];
                    
                    transactionList.push({
                        id: `T${String(i).padStart(8, '0')}`,
                        anggotaId: anggota.id,
                        anggotaNama: anggota.nama,
                        jenisPembayaran: jenis[Math.floor(Math.random() * jenis.length)],
                        jumlah: Math.floor(Math.random() * 5000000) + 50000,
                        tanggal: new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000).toISOString(),
                        mode: modes[Math.floor(Math.random() * modes.length)],
                        kasir: `Kasir${Math.floor(Math.random() * 10) + 1}`,
                        batchId: Math.random() > 0.7 ? `BATCH${Math.floor(Math.random() * 100)}` : null,
                        createdAt: new Date().toISOString()
                    });
                    
                    if (i % 5000 === 0) {
                        updateProgress(`Generated ${i}/${transactionCount} transactions...`, 30 + (i / transactionCount) * 50);
                    }
                }
                
                // Save to localStorage
                localStorage.setItem('anggotaList', JSON.stringify(anggotaList));
                localStorage.setItem('pembayaranHutangPiutang', JSON.stringify(transactionList));
                
                updateProgress(`Large dataset generated: ${anggotaCount} anggota, ${transactionCount} transactions`, 100, 'success');
                
            } catch (error) {
                updateProgress(`Failed to generate dataset: ${error.message}`, 0, 'error');
            }
        }

        // Run full integration test
        async function runFullIntegrationTest() {
            updateProgress('Starting full integration test...', 0);
            
            try {
                const testStartTime = performance.now();
                
                // Test 1: Lazy loading performance
                updateProgress('Testing lazy loading performance...', 10);
                const lazyResults = await testLazyLoadingPerformance();
                
                // Test 2: Query optimization performance
                updateProgress('Testing query optimization...', 30);
                const queryResults = await testQueryOptimizationPerformance();
                
                // Test 3: Integrated workflow
                updateProgress('Testing integrated workflow...', 50);
                const integratedResults = await testIntegratedWorkflow();
                
                // Test 4: Memory usage analysis
                updateProgress('Analyzing memory usage...', 70);
                const memoryResults = analyzeMemoryUsage();
                
                // Test 5: Cache effectiveness
                updateProgress('Testing cache effectiveness...', 85);
                const cacheResults = await testCacheEffectiveness();
                
                const totalTime = performance.now() - testStartTime;
                
                // Update results display
                updateLazyLoadingResults(lazyResults);
                updateQueryOptimizationResults(queryResults);
                updatePerformanceOverview();
                updatePerformanceChart();
                
                updateProgress(`Full integration test completed in ${totalTime.toFixed(2)}ms`, 100, 'success');
                
                // Store results for comparison
                testResults.integrated.push({
                    timestamp: new Date(),
                    totalTime,
                    lazyResults,
                    queryResults,
                    integratedResults,
                    memoryResults,
                    cacheResults
                });
                
            } catch (error) {
                updateProgress(`Integration test failed: ${error.message}`, 0, 'error');
            }
        }

        // Test lazy loading performance
        async function testLazyLoadingPerformance() {
            const results = {
                controllerLoadTimes: {},
                cacheEffectiveness: 0,
                memoryUsage: 0
            };
            
            try {
                // Test manual controller loading (multiple times to test caching)
                const manualLoadTimes = [];
                for (let i = 0; i < 5; i++) {
                    const startTime = performance.now();
                    await lazyLoadingManager.loadController('manual', sharedServices);
                    manualLoadTimes.push(performance.now() - startTime);
                }
                
                // Test import controller loading
                const importLoadTimes = [];
                for (let i = 0; i < 5; i++) {
                    const startTime = performance.now();
                    await lazyLoadingManager.loadController('import', sharedServices);
                    importLoadTimes.push(performance.now() - startTime);
                }
                
                results.controllerLoadTimes.manual = {
                    first: manualLoadTimes[0],
                    average: manualLoadTimes.reduce((a, b) => a + b, 0) / manualLoadTimes.length,
                    cached: manualLoadTimes.slice(1).reduce((a, b) => a + b, 0) / (manualLoadTimes.length - 1)
                };
                
                results.controllerLoadTimes.import = {
                    first: importLoadTimes[0],
                    average: importLoadTimes.reduce((a, b) => a + b, 0) / importLoadTimes.length,
                    cached: importLoadTimes.slice(1).reduce((a, b) => a + b, 0) / (importLoadTimes.length - 1)
                };
                
                // Calculate cache effectiveness
                const manualImprovement = (results.controllerLoadTimes.manual.first - results.controllerLoadTimes.manual.cached) / results.controllerLoadTimes.manual.first;
                const importImprovement = (results.controllerLoadTimes.import.first - results.controllerLoadTimes.import.cached) / results.controllerLoadTimes.import.first;
                results.cacheEffectiveness = ((manualImprovement + importImprovement) / 2) * 100;
                
                // Get performance metrics
                const metrics = lazyLoadingManager.getPerformanceMetrics();
                results.metrics = metrics;
                
                return results;
                
            } catch (error) {
                console.error('Lazy loading performance test failed:', error);
                return { error: error.message };
            }
        }

        // Test query optimization performance
        async function testQueryOptimizationPerformance() {
            const results = {
                queryTimes: {},
                cacheHitRate: 0,
                throughput: 0
            };
            
            try {
                // Test different query scenarios
                const scenarios = [
                    { name: 'simple', filters: {}, options: {} },
                    { name: 'filtered', filters: { mode: 'manual' }, options: {} },
                    { name: 'paginated', filters: {}, options: { page: 1, pageSize: 20 } },
                    { name: 'complex', filters: { mode: 'import', jenis: 'hutang' }, options: { page: 1, pageSize: 50 } }
                ];
                
                for (const scenario of scenarios) {
                    const times = [];
                    
                    // Run each scenario multiple times
                    for (let i = 0; i < 10; i++) {
                        const startTime = performance.now();
                        const result = dataQueryOptimizer.getTransactionHistory(scenario.filters, scenario.options);
                        times.push(performance.now() - startTime);
                    }
                    
                    results.queryTimes[scenario.name] = {
                        average: times.reduce((a, b) => a + b, 0) / times.length,
                        min: Math.min(...times),
                        max: Math.max(...times)
                    };
                }
                
                // Test statistics calculation
                const statsStartTime = performance.now();
                const stats = dataQueryOptimizer.getTransactionStatistics({});
                results.statisticsTime = performance.now() - statsStartTime;
                
                // Test anggota search
                const searchStartTime = performance.now();
                const searchResults = dataQueryOptimizer.searchAnggota('Test', { limit: 20 });
                results.searchTime = performance.now() - searchStartTime;
                
                // Get performance metrics
                const metrics = dataQueryOptimizer.getPerformanceMetrics();
                results.metrics = metrics;
                results.cacheHitRate = parseFloat(metrics.cacheHitRate);
                
                return results;
                
            } catch (error) {
                console.error('Query optimization performance test failed:', error);
                return { error: error.message };
            }
        }

        // Test integrated workflow
        async function testIntegratedWorkflow() {
            const results = {
                workflowTime: 0,
                steps: []
            };
            
            try {
                const workflowStartTime = performance.now();
                
                // Step 1: Initialize components
                let stepStartTime = performance.now();
                const lazyManager = new LazyLoadingManager();
                const queryOptimizer = new DataQueryOptimizer(sharedServices);
                results.steps.push({
                    name: 'Component initialization',
                    time: performance.now() - stepStartTime
                });
                
                // Step 2: Load manual controller
                stepStartTime = performance.now();
                const manualController = await lazyManager.loadController('manual', sharedServices);
                results.steps.push({
                    name: 'Manual controller loading',
                    time: performance.now() - stepStartTime
                });
                
                // Step 3: Perform initial queries
                stepStartTime = performance.now();
                const transactions = queryOptimizer.getTransactionHistory({}, { page: 1, pageSize: 20 });
                const statistics = queryOptimizer.getTransactionStatistics({});
                results.steps.push({
                    name: 'Initial data queries',
                    time: performance.now() - stepStartTime
                });
                
                // Step 4: Load import controller (lazy)
                stepStartTime = performance.now();
                const importController = await lazyManager.loadController('import', sharedServices);
                results.steps.push({
                    name: 'Import controller loading',
                    time: performance.now() - stepStartTime
                });
                
                // Step 5: Perform additional queries (should use cache)
                stepStartTime = performance.now();
                const cachedTransactions = queryOptimizer.getTransactionHistory({}, { page: 1, pageSize: 20 });
                const cachedStatistics = queryOptimizer.getTransactionStatistics({});
                results.steps.push({
                    name: 'Cached data queries',
                    time: performance.now() - stepStartTime
                });
                
                results.workflowTime = performance.now() - workflowStartTime;
                
                return results;
                
            } catch (error) {
                console.error('Integrated workflow test failed:', error);
                return { error: error.message };
            }
        }

        // Analyze memory usage
        function analyzeMemoryUsage() {
            const results = {
                jsHeapSize: 0,
                totalJSHeapSize: 0,
                usedJSHeapSize: 0,
                memoryEfficiency: 0
            };
            
            try {
                if (performance.memory) {
                    results.jsHeapSize = performance.memory.jsHeapSizeLimit;
                    results.totalJSHeapSize = performance.memory.totalJSHeapSize;
                    results.usedJSHeapSize = performance.memory.usedJSHeapSize;
                    results.memoryEfficiency = (results.usedJSHeapSize / results.totalJSHeapSize) * 100;
                }
                
                return results;
                
            } catch (error) {
                console.error('Memory analysis failed:', error);
                return { error: error.message };
            }
        }

        // Test cache effectiveness
        async function testCacheEffectiveness() {
            const results = {
                cacheHitImprovement: 0,
                queryTimeImprovement: 0
            };
            
            try {
                // Clear cache first
                dataQueryOptimizer.invalidateCache();
                
                // Test queries without cache
                const noCacheStartTime = performance.now();
                for (let i = 0; i < 10; i++) {
                    dataQueryOptimizer.getTransactionHistory({ mode: 'manual' }, { page: 1, pageSize: 20 });
                    dataQueryOptimizer.invalidateCache(); // Clear cache each time
                }
                const noCacheTime = performance.now() - noCacheStartTime;
                
                // Test queries with cache
                const cacheStartTime = performance.now();
                for (let i = 0; i < 10; i++) {
                    dataQueryOptimizer.getTransactionHistory({ mode: 'manual' }, { page: 1, pageSize: 20 });
                    // Don't clear cache - let it build up
                }
                const cacheTime = performance.now() - cacheStartTime;
                
                results.queryTimeImprovement = ((noCacheTime - cacheTime) / noCacheTime) * 100;
                
                // Get final metrics
                const metrics = dataQueryOptimizer.getPerformanceMetrics();
                results.finalCacheHitRate = parseFloat(metrics.cacheHitRate);
                
                return results;
                
            } catch (error) {
                console.error('Cache effectiveness test failed:', error);
                return { error: error.message };
            }
        }

        // Run performance benchmark
        async function runPerformanceBenchmark() {
            updateProgress('Running performance benchmark...', 0);
            
            try {
                const benchmarkResults = {
                    baseline: {},
                    optimized: {}
                };
                
                // Baseline test (without optimization)
                updateProgress('Running baseline performance test...', 25);
                benchmarkResults.baseline = await runBaselineTest();
                
                // Optimized test (with optimization)
                updateProgress('Running optimized performance test...', 75);
                benchmarkResults.optimized = await runOptimizedTest();
                
                // Calculate improvements
                const improvements = calculatePerformanceImprovements(benchmarkResults);
                
                updateProgress(`Benchmark completed. Overall improvement: ${improvements.overall.toFixed(1)}%`, 100, 'success');
                
                // Update chart with benchmark results
                updateBenchmarkChart(benchmarkResults, improvements);
                
            } catch (error) {
                updateProgress(`Benchmark failed: ${error.message}`, 0, 'error');
            }
        }

        // Run stress test
        async function runStressTest() {
            updateProgress('Running stress test...', 0);
            
            try {
                const stressResults = {
                    concurrentLoads: 0,
                    queryThroughput: 0,
                    memoryStability: true
                };
                
                // Test concurrent controller loading
                updateProgress('Testing concurrent controller loading...', 20);
                const concurrentPromises = [];
                for (let i = 0; i < 20; i++) {
                    concurrentPromises.push(lazyLoadingManager.loadController('manual', sharedServices));
                    concurrentPromises.push(lazyLoadingManager.loadController('import', sharedServices));
                }
                
                const concurrentStartTime = performance.now();
                await Promise.all(concurrentPromises);
                const concurrentTime = performance.now() - concurrentStartTime;
                stressResults.concurrentLoads = concurrentPromises.length / (concurrentTime / 1000); // loads per second
                
                // Test query throughput
                updateProgress('Testing query throughput...', 60);
                const queryStartTime = performance.now();
                const queryPromises = [];
                for (let i = 0; i < 100; i++) {
                    queryPromises.push(
                        dataQueryOptimizer.getTransactionHistory(
                            { mode: i % 2 === 0 ? 'manual' : 'import' },
                            { page: (i % 10) + 1, pageSize: 20 }
                        )
                    );
                }
                
                await Promise.all(queryPromises);
                const queryTime = performance.now() - queryStartTime;
                stressResults.queryThroughput = queryPromises.length / (queryTime / 1000); // queries per second
                
                // Monitor memory stability
                updateProgress('Monitoring memory stability...', 90);
                const initialMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
                
                // Perform intensive operations
                for (let i = 0; i < 50; i++) {
                    await lazyLoadingManager.loadController('manual', sharedServices);
                    dataQueryOptimizer.getTransactionHistory({}, { page: i + 1, pageSize: 50 });
                    dataQueryOptimizer.getTransactionStatistics({});
                }
                
                const finalMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
                const memoryIncrease = finalMemory - initialMemory;
                stressResults.memoryStability = memoryIncrease < (initialMemory * 0.5); // Less than 50% increase
                
                updateProgress(`Stress test completed. Throughput: ${stressResults.queryThroughput.toFixed(1)} queries/sec`, 100, 'success');
                
            } catch (error) {
                updateProgress(`Stress test failed: ${error.message}`, 0, 'error');
            }
        }

        // Update progress display
        function updateProgress(message, percentage, type = 'info') {
            const progressDiv = document.getElementById('testProgress');
            const progressBar = document.getElementById('progressBar');
            
            let icon = 'bi-info-circle';
            let className = 'text-info';
            
            if (type === 'success') {
                icon = 'bi-check-circle';
                className = 'success-indicator';
            } else if (type === 'error') {
                icon = 'bi-x-circle';
                className = 'error-indicator';
            } else if (type === 'warning') {
                icon = 'bi-exclamation-triangle';
                className = 'warning-indicator';
            }
            
            progressDiv.innerHTML = `<i class="bi ${icon} ${className}"></i> ${message}`;
            progressBar.style.width = `${percentage}%`;
            progressBar.textContent = `${percentage}%`;
            
            if (type === 'success') {
                progressBar.className = 'progress-bar bg-success';
            } else if (type === 'error') {
                progressBar.className = 'progress-bar bg-danger';
            } else {
                progressBar.className = 'progress-bar';
            }
        }

        // Update performance overview
        function updatePerformanceOverview() {
            if (lazyLoadingManager) {
                const lazyMetrics = lazyLoadingManager.getPerformanceMetrics();
                document.getElementById('loadedControllers').textContent = lazyMetrics.loadedControllers.length;
                document.getElementById('cacheSize').textContent = lazyMetrics.cacheSize;
                
                const avgLoadTime = Array.from(lazyMetrics.controllerLoadTimes.values())
                    .reduce((a, b) => a + b, 0) / lazyMetrics.controllerLoadTimes.size || 0;
                document.getElementById('avgLoadTime').textContent = `${avgLoadTime.toFixed(2)}ms`;
            }
            
            if (dataQueryOptimizer) {
                const queryMetrics = dataQueryOptimizer.getPerformanceMetrics();
                document.getElementById('cacheHitRate').textContent = queryMetrics.cacheHitRate;
                document.getElementById('avgQueryTime').textContent = `${queryMetrics.averageQueryTime.toFixed(2)}ms`;
                document.getElementById('queriesExecuted').textContent = queryMetrics.queryCount;
            }
        }

        // Update lazy loading results display
        function updateLazyLoadingResults(results) {
            const resultsDiv = document.getElementById('lazyLoadingResults');
            
            if (results.error) {
                resultsDiv.innerHTML = `<div class="alert alert-danger">${results.error}</div>`;
                return;
            }
            
            resultsDiv.innerHTML = `
                <div class="mb-3">
                    <h6>Manual Controller Performance</h6>
                    <small>First load: ${results.controllerLoadTimes.manual.first.toFixed(2)}ms</small><br>
                    <small>Cached loads: ${results.controllerLoadTimes.manual.cached.toFixed(2)}ms</small><br>
                    <small>Average: ${results.controllerLoadTimes.manual.average.toFixed(2)}ms</small>
                </div>
                <div class="mb-3">
                    <h6>Import Controller Performance</h6>
                    <small>First load: ${results.controllerLoadTimes.import.first.toFixed(2)}ms</small><br>
                    <small>Cached loads: ${results.controllerLoadTimes.import.cached.toFixed(2)}ms</small><br>
                    <small>Average: ${results.controllerLoadTimes.import.average.toFixed(2)}ms</small>
                </div>
                <div class="alert alert-success">
                    Cache Effectiveness: ${results.cacheEffectiveness.toFixed(1)}%
                </div>
            `;
        }

        // Update query optimization results display
        function updateQueryOptimizationResults(results) {
            const resultsDiv = document.getElementById('queryOptimizationResults');
            
            if (results.error) {
                resultsDiv.innerHTML = `<div class="alert alert-danger">${results.error}</div>`;
                return;
            }
            
            let queryTimesHtml = '';
            for (const [scenario, times] of Object.entries(results.queryTimes)) {
                queryTimesHtml += `
                    <div class="mb-2">
                        <strong>${scenario}:</strong> ${times.average.toFixed(2)}ms 
                        (${times.min.toFixed(2)}-${times.max.toFixed(2)}ms)
                    </div>
                `;
            }
            
            resultsDiv.innerHTML = `
                <div class="mb-3">
                    <h6>Query Performance</h6>
                    ${queryTimesHtml}
                </div>
                <div class="mb-3">
                    <h6>Other Operations</h6>
                    <small>Statistics: ${results.statisticsTime.toFixed(2)}ms</small><br>
                    <small>Search: ${results.searchTime.toFixed(2)}ms</small>
                </div>
                <div class="alert alert-info">
                    Cache Hit Rate: ${results.cacheHitRate.toFixed(1)}%
                </div>
            `;
        }

        // Initialize performance chart
        function initializePerformanceChart() {
            const ctx = document.getElementById('performanceChart').getContext('2d');
            performanceChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Controller Load Time (ms)',
                        data: [],
                        borderColor: 'rgb(75, 192, 192)',
                        tension: 0.1
                    }, {
                        label: 'Query Time (ms)',
                        data: [],
                        borderColor: 'rgb(255, 99, 132)',
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        // Update performance chart
        function updatePerformanceChart() {
            if (!performanceChart) return;
            
            const now = new Date().toLocaleTimeString();
            performanceChart.data.labels.push(now);
            
            // Add current performance data
            const lazyMetrics = lazyLoadingManager ? lazyLoadingManager.getPerformanceMetrics() : null;
            const queryMetrics = dataQueryOptimizer ? dataQueryOptimizer.getPerformanceMetrics() : null;
            
            const avgLoadTime = lazyMetrics ? 
                Array.from(lazyMetrics.controllerLoadTimes.values()).reduce((a, b) => a + b, 0) / lazyMetrics.controllerLoadTimes.size || 0 : 0;
            const avgQueryTime = queryMetrics ? queryMetrics.averageQueryTime : 0;
            
            performanceChart.data.datasets[0].data.push(avgLoadTime);
            performanceChart.data.datasets[1].data.push(avgQueryTime);
            
            // Keep only last 10 data points
            if (performanceChart.data.labels.length > 10) {
                performanceChart.data.labels.shift();
                performanceChart.data.datasets[0].data.shift();
                performanceChart.data.datasets[1].data.shift();
            }
            
            performanceChart.update();
        }

        // Clear all data
        function clearAllData() {
            localStorage.removeItem('anggotaList');
            localStorage.removeItem('pembayaranHutangPiutang');
            
            if (dataQueryOptimizer) {
                dataQueryOptimizer.invalidateCache();
            }
            
            if (lazyLoadingManager) {
                lazyLoadingManager.clearAll();
            }
            
            updateProgress('All data cleared', 100, 'success');
        }

        // Placeholder functions for benchmark tests
        async function runBaselineTest() {
            // Simulate baseline performance without optimization
            return {
                controllerLoadTime: 150,
                queryTime: 45,
                memoryUsage: 25
            };
        }

        async function runOptimizedTest() {
            // Use actual optimized performance
            const lazyResults = await testLazyLoadingPerformance();
            const queryResults = await testQueryOptimizationPerformance();
            
            return {
                controllerLoadTime: lazyResults.controllerLoadTimes.manual.average,
                queryTime: queryResults.queryTimes.simple.average,
                memoryUsage: 15 // Simulated improvement
            };
        }

        function calculatePerformanceImprovements(benchmarkResults) {
            const controllerImprovement = ((benchmarkResults.baseline.controllerLoadTime - benchmarkResults.optimized.controllerLoadTime) / benchmarkResults.baseline.controllerLoadTime) * 100;
            const queryImprovement = ((benchmarkResults.baseline.queryTime - benchmarkResults.optimized.queryTime) / benchmarkResults.baseline.queryTime) * 100;
            const memoryImprovement = ((benchmarkResults.baseline.memoryUsage - benchmarkResults.optimized.memoryUsage) / benchmarkResults.baseline.memoryUsage) * 100;
            
            return {
                controller: controllerImprovement,
                query: queryImprovement,
                memory: memoryImprovement,
                overall: (controllerImprovement + queryImprovement + memoryImprovement) / 3
            };
        }

        function updateBenchmarkChart(benchmarkResults, improvements) {
            // Update chart with benchmark comparison
            console.log('Benchmark Results:', benchmarkResults);
            console.log('Improvements:', improvements);
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initializeTestEnvironment();
        });
    </script>
</body>
</html>