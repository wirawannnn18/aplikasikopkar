<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Task 11 - Integration Testing & Performance Optimization</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
    <style>
        .test-section {
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .test-result {
            padding: 10px;
            border-radius: 4px;
            margin: 5px 0;
        }
        .test-success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }
        .test-error {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }
        .test-info {
            background-color: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
        }
        .performance-metric {
            background: #f8f9fa;
            border-left: 4px solid #007bff;
            padding: 10px;
            margin: 5px 0;
        }
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-4">
        <div class="row">
            <div class="col-12">
                <h1><i class="bi bi-speedometer2 me-2"></i>Task 11: Integration Testing & Performance Optimization</h1>
                <p class="text-muted">Comprehensive testing of integration workflows and performance optimizations</p>
                
                <!-- Control Panel -->
                <div class="card mb-4">
                    <div class="card-header">
                        <h5><i class="bi bi-gear me-2"></i>Test Control Panel</h5>
                    </div>
                    <div class="card-body">
                        <div class="row">
                            <div class="col-md-6">
                                <button class="btn btn-primary me-2" onclick="runAllTests()">
                                    <i class="bi bi-play-fill me-1"></i>Run All Tests
                                </button>
                                <button class="btn btn-success me-2" onclick="runIntegrationTests()">
                                    <i class="bi bi-diagram-3 me-1"></i>Integration Tests
                                </button>
                                <button class="btn btn-warning me-2" onclick="runPerformanceTests()">
                                    <i class="bi bi-speedometer me-1"></i>Performance Tests
                                </button>
                            </div>
                            <div class="col-md-6 text-end">
                                <button class="btn btn-outline-secondary" onclick="clearResults()">
                                    <i class="bi bi-trash me-1"></i>Clear Results
                                </button>
                                <button class="btn btn-outline-info" onclick="exportResults()">
                                    <i class="bi bi-download me-1"></i>Export Results
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Test Results -->
                <div class="row">
                    <!-- Integration Tests -->
                    <div class="col-lg-6">
                        <div class="test-section">
                            <h4><i class="bi bi-diagram-3 me-2"></i>Integration Tests</h4>
                            <div id="integration-results">
                                <div class="test-info">
                                    <i class="bi bi-info-circle me-2"></i>Click "Integration Tests" to start testing
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Performance Tests -->
                    <div class="col-lg-6">
                        <div class="test-section">
                            <h4><i class="bi bi-speedometer me-2"></i>Performance Tests</h4>
                            <div id="performance-results">
                                <div class="test-info">
                                    <i class="bi bi-info-circle me-2"></i>Click "Performance Tests" to start testing
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Performance Metrics -->
                <div class="row mt-4">
                    <div class="col-12">
                        <div class="test-section">
                            <h4><i class="bi bi-graph-up me-2"></i>Performance Metrics</h4>
                            <div id="performance-metrics">
                                <div class="test-info">
                                    <i class="bi bi-info-circle me-2"></i>Performance metrics will appear here after running tests
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Error Scenarios -->
                <div class="row mt-4">
                    <div class="col-12">
                        <div class="test-section">
                            <h4><i class="bi bi-exclamation-triangle me-2"></i>Error Scenario Tests</h4>
                            <div id="error-scenario-results">
                                <div class="test-info">
                                    <i class="bi bi-info-circle me-2"></i>Error scenario tests will run as part of integration tests
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Transformasi Barang Modules -->
    <script src="js/transformasi-barang/types.js"></script>
    <script src="js/transformasi-barang/DataModels.js"></script>
    <script src="js/transformasi-barang/ValidationEngine.js"></script>
    <script src="js/transformasi-barang/ConversionCalculator.js"></script>
    <script src="js/transformasi-barang/StockManager.js"></script>
    <script src="js/transformasi-barang/AuditLogger.js"></script>
    <script src="js/transformasi-barang/ErrorHandler.js"></script>
    <script src="js/transformasi-barang/TransformationManager.js"></script>
    <script src="js/transformasi-barang/UIController.js"></script>
    <script src="js/transformasi-barang/ReportManager.js"></script>
    <script src="js/transformasi-barang/PerformanceOptimizer.js"></script>

    <script>
        // Global variables
        let transformationManager;
        let performanceOptimizer;
        let testResults = {
            integration: [],
            performance: [],
            errors: []
        };

        // Initialize system
        document.addEventListener('DOMContentLoaded', async function() {
            await initializeSystem();
        });

        /**
         * Initialize transformation system with performance optimization
         */
        async function initializeSystem() {
            try {
                // Setup sample data
                setupSampleData();

                // Initialize components
                const validationEngine = new ValidationEngine();
                const calculator = new ConversionCalculator();
                const stockManager = new StockManager();
                const auditLogger = new AuditLogger();
                const errorHandler = new ErrorHandler();
                
                // Initialize performance optimizer
                performanceOptimizer = new PerformanceOptimizer();
                performanceOptimizer.initialize();

                // Initialize transformation manager
                transformationManager = new TransformationManager();
                transformationManager.initialize({
                    validationEngine,
                    calculator,
                    stockManager,
                    auditLogger
                });

                console.log('System initialized successfully');
            } catch (error) {
                console.error('Error initializing system:', error);
                addResult('integration', 'System Initialization', false, error.message);
            }
        }

        /**
         * Run all tests
         */
        async function runAllTests() {
            clearResults();
            await runIntegrationTests();
            await runPerformanceTests();
            updatePerformanceMetrics();
        }

        /**
         * Run integration tests
         */
        async function runIntegrationTests() {
            const resultsContainer = document.getElementById('integration-results');
            resultsContainer.innerHTML = '<div class="test-info"><span class="loading-spinner me-2"></span>Running integration tests...</div>';

            try {
                // Test 1: Complete transformation workflow
                await testCompleteTransformationWorkflow();

                // Test 2: Concurrent transformations
                await testConcurrentTransformations();

                // Test 3: Data consistency
                await testDataConsistency();

                // Test 4: Error handling and recovery
                await testErrorHandlingAndRecovery();

                // Test 5: localStorage integration
                await testLocalStorageIntegration();

                // Test 6: UI integration
                await testUIIntegration();

                displayIntegrationResults();
            } catch (error) {
                console.error('Error running integration tests:', error);
                addResult('integration', 'Integration Test Suite', false, error.message);
                displayIntegrationResults();
            }
        }

        /**
         * Run performance tests
         */
        async function runPerformanceTests() {
            const resultsContainer = document.getElementById('performance-results');
            resultsContainer.innerHTML = '<div class="test-info"><span class="loading-spinner me-2"></span>Running performance tests...</div>';

            try {
                // Test 1: Cache performance
                await testCachePerformance();

                // Test 2: Large dataset handling
                await testLargeDatasetHandling();

                // Test 3: Concurrent operations performance
                await testConcurrentOperationsPerformance();

                // Test 4: Memory optimization
                await testMemoryOptimization();

                // Test 5: Debouncing effectiveness
                await testDebouncingEffectiveness();

                // Test 6: Batch processing performance
                await testBatchProcessingPerformance();

                displayPerformanceResults();
            } catch (error) {
                console.error('Error running performance tests:', error);
                addResult('performance', 'Performance Test Suite', false, error.message);
                displayPerformanceResults();
            }
        }

        /**
         * Test complete transformation workflow
         */
        async function testCompleteTransformationWorkflow() {
            const startTime = performance.now();
            
            try {
                const transformationData = {
                    sourceItemId: 'AQUA-DUS',
                    targetItemId: 'AQUA-PCS',
                    quantity: 2,
                    user: 'kasir01'
                };

                // Execute transformation
                const result = await transformationManager.executeTransformation(transformationData);

                // Verify result
                if (result.status === 'completed' && 
                    result.sourceItem.quantity === 2 && 
                    result.targetItem.quantity === 24) {
                    
                    const duration = performance.now() - startTime;
                    addResult('integration', 'Complete Transformation Workflow', true, 
                        `Transformation completed successfully in ${duration.toFixed(2)}ms`);
                } else {
                    addResult('integration', 'Complete Transformation Workflow', false, 
                        'Transformation result validation failed');
                }
            } catch (error) {
                addResult('integration', 'Complete Transformation Workflow', false, error.message);
            }
        }

        /**
         * Test concurrent transformations
         */
        async function testConcurrentTransformations() {
            const startTime = performance.now();
            
            try {
                // Setup multiple transformations
                const transformations = [
                    { sourceItemId: 'AQUA-DUS', targetItemId: 'AQUA-PCS', quantity: 1, user: 'kasir01' },
                    { sourceItemId: 'AQUA-DUS', targetItemId: 'AQUA-PCS', quantity: 1, user: 'kasir02' },
                    { sourceItemId: 'AQUA-DUS', targetItemId: 'AQUA-PCS', quantity: 1, user: 'kasir03' }
                ];

                // Execute concurrent transformations
                const results = await Promise.allSettled(
                    transformations.map(t => transformationManager.executeTransformation(t))
                );

                // Verify results
                const successfulResults = results.filter(r => 
                    r.status === 'fulfilled' && r.value.status === 'completed'
                );

                if (successfulResults.length === 3) {
                    const duration = performance.now() - startTime;
                    addResult('integration', 'Concurrent Transformations', true, 
                        `3 concurrent transformations completed in ${duration.toFixed(2)}ms`);
                } else {
                    addResult('integration', 'Concurrent Transformations', false, 
                        `Only ${successfulResults.length}/3 transformations succeeded`);
                }
            } catch (error) {
                addResult('integration', 'Concurrent Transformations', false, error.message);
            }
        }

        /**
         * Test data consistency
         */
        async function testDataConsistency() {
            try {
                // Get initial state
                const initialMasterBarang = JSON.parse(localStorage.getItem('masterBarang'));
                const initialSourceStock = initialMasterBarang.find(item => item.kode === 'AQUA-DUS').stok;
                const initialTargetStock = initialMasterBarang.find(item => item.kode === 'AQUA-PCS').stok;

                // Execute transformation
                const transformationData = {
                    sourceItemId: 'AQUA-DUS',
                    targetItemId: 'AQUA-PCS',
                    quantity: 1,
                    user: 'kasir01'
                };

                await transformationManager.executeTransformation(transformationData);

                // Verify consistency across all components
                const updatedMasterBarang = JSON.parse(localStorage.getItem('masterBarang'));
                const sourceItem = updatedMasterBarang.find(item => item.kode === 'AQUA-DUS');
                const targetItem = updatedMasterBarang.find(item => item.kode === 'AQUA-PCS');

                const stockManagerSourceStock = await transformationManager.stockManager.getStockBalance('AQUA-DUS');
                const stockManagerTargetStock = await transformationManager.stockManager.getStockBalance('AQUA-PCS');

                const history = await transformationManager.getTransformationHistory();
                const lastTransformation = history[history.length - 1];

                // Verify consistency
                const sourceConsistent = sourceItem.stok === stockManagerSourceStock && 
                                       sourceItem.stok === lastTransformation.sourceItem.stockAfter;
                const targetConsistent = targetItem.stok === stockManagerTargetStock && 
                                       targetItem.stok === lastTransformation.targetItem.stockAfter;

                if (sourceConsistent && targetConsistent) {
                    addResult('integration', 'Data Consistency', true, 
                        'All components maintain consistent data state');
                } else {
                    addResult('integration', 'Data Consistency', false, 
                        'Data inconsistency detected between components');
                }
            } catch (error) {
                addResult('integration', 'Data Consistency', false, error.message);
            }
        }

        /**
         * Test error handling and recovery
         */
        async function testErrorHandlingAndRecovery() {
            try {
                // Test insufficient stock error
                const invalidTransformation = {
                    sourceItemId: 'AQUA-DUS',
                    targetItemId: 'AQUA-PCS',
                    quantity: 1000, // More than available
                    user: 'kasir01'
                };

                let errorCaught = false;
                try {
                    await transformationManager.executeTransformation(invalidTransformation);
                } catch (error) {
                    errorCaught = true;
                    if (error.message.includes('Stok tidak mencukupi') || 
                        error.message.includes('tidak mencukupi')) {
                        addResult('integration', 'Error Handling - Insufficient Stock', true, 
                            'Insufficient stock error properly handled');
                    } else {
                        addResult('integration', 'Error Handling - Insufficient Stock', false, 
                            `Unexpected error message: ${error.message}`);
                    }
                }

                if (!errorCaught) {
                    addResult('integration', 'Error Handling - Insufficient Stock', false, 
                        'Expected error was not thrown');
                }

                // Test invalid item error
                const invalidItemTransformation = {
                    sourceItemId: 'INVALID-ITEM',
                    targetItemId: 'AQUA-PCS',
                    quantity: 1,
                    user: 'kasir01'
                };

                errorCaught = false;
                try {
                    await transformationManager.executeTransformation(invalidItemTransformation);
                } catch (error) {
                    errorCaught = true;
                    addResult('integration', 'Error Handling - Invalid Item', true, 
                        'Invalid item error properly handled');
                }

                if (!errorCaught) {
                    addResult('integration', 'Error Handling - Invalid Item', false, 
                        'Expected error was not thrown');
                }

            } catch (error) {
                addResult('integration', 'Error Handling and Recovery', false, error.message);
            }
        }

        /**
         * Test localStorage integration
         */
        async function testLocalStorageIntegration() {
            try {
                // Test data persistence
                const transformationData = {
                    sourceItemId: 'AQUA-DUS',
                    targetItemId: 'AQUA-PCS',
                    quantity: 1,
                    user: 'kasir01'
                };

                await transformationManager.executeTransformation(transformationData);

                // Verify localStorage updates
                const masterBarang = localStorage.getItem('masterBarang');
                const history = localStorage.getItem('transformationHistory');

                if (masterBarang && history) {
                    const parsedMasterBarang = JSON.parse(masterBarang);
                    const parsedHistory = JSON.parse(history);

                    if (Array.isArray(parsedMasterBarang) && Array.isArray(parsedHistory) && 
                        parsedHistory.length > 0) {
                        addResult('integration', 'localStorage Integration', true, 
                            'Data properly persisted to localStorage');
                    } else {
                        addResult('integration', 'localStorage Integration', false, 
                            'Invalid data structure in localStorage');
                    }
                } else {
                    addResult('integration', 'localStorage Integration', false, 
                        'Required data not found in localStorage');
                }
            } catch (error) {
                addResult('integration', 'localStorage Integration', false, error.message);
            }
        }

        /**
         * Test UI integration
         */
        async function testUIIntegration() {
            try {
                // Create mock DOM elements
                const mockElements = createMockUIElements();

                // Test transformable items loading
                const transformableItems = await transformationManager.getTransformableItems();
                
                if (transformableItems.length > 0) {
                    addResult('integration', 'UI Integration - Data Loading', true, 
                        `Successfully loaded ${transformableItems.length} transformable item groups`);
                } else {
                    addResult('integration', 'UI Integration - Data Loading', false, 
                        'No transformable items loaded');
                }

                // Test form validation simulation
                const validationResult = await transformationManager.validateTransformation(
                    'AQUA-DUS', 'AQUA-PCS', 1
                );

                if (validationResult.isValid) {
                    addResult('integration', 'UI Integration - Form Validation', true, 
                        'Form validation working correctly');
                } else {
                    addResult('integration', 'UI Integration - Form Validation', false, 
                        `Validation failed: ${validationResult.errors.join(', ')}`);
                }

                // Cleanup mock elements
                cleanupMockUIElements(mockElements);
            } catch (error) {
                addResult('integration', 'UI Integration', false, error.message);
            }
        }

        /**
         * Test cache performance
         */
        async function testCachePerformance() {
            try {
                const cacheKey = 'test-transformable-items';
                const dataProvider = () => transformationManager.getTransformableItems();

                // First access (cache miss)
                const startTime1 = performance.now();
                const data1 = await performanceOptimizer.getCachedData(cacheKey, dataProvider);
                const endTime1 = performance.now();
                const firstAccessTime = endTime1 - startTime1;

                // Second access (cache hit)
                const startTime2 = performance.now();
                const data2 = await performanceOptimizer.getCachedData(cacheKey, dataProvider);
                const endTime2 = performance.now();
                const secondAccessTime = endTime2 - startTime2;

                // Verify cache effectiveness
                if (secondAccessTime < firstAccessTime * 0.5) {
                    addResult('performance', 'Cache Performance', true, 
                        `Cache hit 50%+ faster: ${firstAccessTime.toFixed(2)}ms → ${secondAccessTime.toFixed(2)}ms`);
                } else {
                    addResult('performance', 'Cache Performance', false, 
                        `Cache not effective: ${firstAccessTime.toFixed(2)}ms → ${secondAccessTime.toFixed(2)}ms`);
                }
            } catch (error) {
                addResult('performance', 'Cache Performance', false, error.message);
            }
        }

        /**
         * Test large dataset handling
         */
        async function testLargeDatasetHandling() {
            try {
                // Generate large dataset
                const largeDataset = generateLargeDataset(1000);
                localStorage.setItem('masterBarang', JSON.stringify(largeDataset));

                const startTime = performance.now();
                const transformableItems = await transformationManager.getTransformableItems();
                const endTime = performance.now();
                const duration = endTime - startTime;

                // Restore original dataset
                setupSampleData();

                if (duration < 100) { // Should complete within 100ms
                    addResult('performance', 'Large Dataset Handling', true, 
                        `Processed 1000 items in ${duration.toFixed(2)}ms`);
                } else {
                    addResult('performance', 'Large Dataset Handling', false, 
                        `Too slow: ${duration.toFixed(2)}ms for 1000 items`);
                }
            } catch (error) {
                addResult('performance', 'Large Dataset Handling', false, error.message);
            }
        }

        /**
         * Test concurrent operations performance
         */
        async function testConcurrentOperationsPerformance() {
            try {
                const operations = [];
                
                // Create 50 concurrent operations
                for (let i = 0; i < 50; i++) {
                    operations.push(transformationManager.getTransformableItems());
                    operations.push(transformationManager.getTransformationHistory());
                }

                const startTime = performance.now();
                const results = await Promise.all(operations);
                const endTime = performance.now();
                const duration = endTime - startTime;

                if (duration < 500 && results.length === 100) {
                    addResult('performance', 'Concurrent Operations', true, 
                        `100 concurrent operations completed in ${duration.toFixed(2)}ms`);
                } else {
                    addResult('performance', 'Concurrent Operations', false, 
                        `Performance issue: ${duration.toFixed(2)}ms for 100 operations`);
                }
            } catch (error) {
                addResult('performance', 'Concurrent Operations', false, error.message);
            }
        }

        /**
         * Test memory optimization
         */
        async function testMemoryOptimization() {
            try {
                // Fill cache with data
                for (let i = 0; i < 100; i++) {
                    await performanceOptimizer.getCachedData(
                        `test-key-${i}`, 
                        () => Promise.resolve(`data-${i}`)
                    );
                }

                const beforeOptimization = performanceOptimizer.getPerformanceMetrics().currentCacheSize;

                // Trigger memory optimization
                performanceOptimizer.optimizeMemory(50); // Limit to 50 entries

                const afterOptimization = performanceOptimizer.getPerformanceMetrics().currentCacheSize;

                if (afterOptimization <= 50 && afterOptimization < beforeOptimization) {
                    addResult('performance', 'Memory Optimization', true, 
                        `Cache reduced from ${beforeOptimization} to ${afterOptimization} entries`);
                } else {
                    addResult('performance', 'Memory Optimization', false, 
                        `Memory optimization failed: ${beforeOptimization} → ${afterOptimization}`);
                }
            } catch (error) {
                addResult('performance', 'Memory Optimization', false, error.message);
            }
        }

        /**
         * Test debouncing effectiveness
         */
        async function testDebouncingEffectiveness() {
            try {
                let executionCount = 0;
                const testFunction = () => {
                    executionCount++;
                    return Promise.resolve(executionCount);
                };

                // Trigger multiple debounced calls rapidly
                const promises = [];
                for (let i = 0; i < 10; i++) {
                    promises.push(performanceOptimizer.debounce('test-debounce', testFunction, 100));
                }

                // Wait for debounce to complete
                await Promise.all(promises);
                
                // Wait a bit more to ensure debounce has settled
                await new Promise(resolve => setTimeout(resolve, 200));

                if (executionCount === 1) {
                    addResult('performance', 'Debouncing Effectiveness', true, 
                        '10 rapid calls debounced to 1 execution');
                } else {
                    addResult('performance', 'Debouncing Effectiveness', false, 
                        `Debouncing failed: ${executionCount} executions instead of 1`);
                }
            } catch (error) {
                addResult('performance', 'Debouncing Effectiveness', false, error.message);
            }
        }

        /**
         * Test batch processing performance
         */
        async function testBatchProcessingPerformance() {
            try {
                let batchProcessCount = 0;
                const batchProcessor = (items) => {
                    batchProcessCount++;
                    return Promise.resolve(items.map(item => `processed-${item}`));
                };

                const promises = [];
                
                // Add 25 items to batch (should trigger 3 batches: 10+10+5)
                for (let i = 0; i < 25; i++) {
                    promises.push(performanceOptimizer.addToBatch(
                        'test-batch', 
                        `item-${i}`, 
                        batchProcessor, 
                        10, // batch size
                        500 // max wait
                    ));
                }

                const results = await Promise.all(promises);

                if (batchProcessCount <= 3 && results.length === 25) {
                    addResult('performance', 'Batch Processing', true, 
                        `25 items processed in ${batchProcessCount} batches`);
                } else {
                    addResult('performance', 'Batch Processing', false, 
                        `Batch processing inefficient: ${batchProcessCount} batches for 25 items`);
                }
            } catch (error) {
                addResult('performance', 'Batch Processing', false, error.message);
            }
        }

        /**
         * Display integration test results
         */
        function displayIntegrationResults() {
            const container = document.getElementById('integration-results');
            const integrationResults = testResults.integration;
            
            if (integrationResults.length === 0) {
                container.innerHTML = '<div class="test-info">No integration tests run yet</div>';
                return;
            }

            const successCount = integrationResults.filter(r => r.success).length;
            const totalCount = integrationResults.length;
            
            let html = `
                <div class="test-info mb-3">
                    <strong>Integration Tests: ${successCount}/${totalCount} passed</strong>
                </div>
            `;

            integrationResults.forEach(result => {
                html += `
                    <div class="test-result ${result.success ? 'test-success' : 'test-error'}">
                        <i class="bi bi-${result.success ? 'check-circle' : 'x-circle'} me-2"></i>
                        <strong>${result.testName}</strong><br>
                        <small>${result.message}</small>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        /**
         * Display performance test results
         */
        function displayPerformanceResults() {
            const container = document.getElementById('performance-results');
            const performanceResults = testResults.performance;
            
            if (performanceResults.length === 0) {
                container.innerHTML = '<div class="test-info">No performance tests run yet</div>';
                return;
            }

            const successCount = performanceResults.filter(r => r.success).length;
            const totalCount = performanceResults.length;
            
            let html = `
                <div class="test-info mb-3">
                    <strong>Performance Tests: ${successCount}/${totalCount} passed</strong>
                </div>
            `;

            performanceResults.forEach(result => {
                html += `
                    <div class="test-result ${result.success ? 'test-success' : 'test-error'}">
                        <i class="bi bi-${result.success ? 'check-circle' : 'x-circle'} me-2"></i>
                        <strong>${result.testName}</strong><br>
                        <small>${result.message}</small>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        /**
         * Update performance metrics display
         */
        function updatePerformanceMetrics() {
            const container = document.getElementById('performance-metrics');
            
            if (!performanceOptimizer) {
                container.innerHTML = '<div class="test-info">Performance optimizer not initialized</div>';
                return;
            }

            const metrics = performanceOptimizer.getPerformanceMetrics();
            
            const html = `
                <div class="row">
                    <div class="col-md-3">
                        <div class="performance-metric">
                            <strong>Cache Hit Rate</strong><br>
                            <span class="h4">${metrics.cacheHitRate}%</span>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="performance-metric">
                            <strong>Cache Size</strong><br>
                            <span class="h4">${metrics.currentCacheSize}</span>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="performance-metric">
                            <strong>Avg Operation Time</strong><br>
                            <span class="h4">${metrics.averageOperationTime.toFixed(2)}ms</span>
                        </div>
                    </div>
                    <div class="col-md-3">
                        <div class="performance-metric">
                            <strong>Total Operations</strong><br>
                            <span class="h4">${metrics.totalCacheHits + metrics.totalCacheMisses}</span>
                        </div>
                    </div>
                </div>
                <div class="mt-3">
                    <h6>Recent Operations:</h6>
                    <div class="small">
                        ${metrics.recentOperations.map(op => 
                            `${op.operation}: ${op.duration.toFixed(2)}ms`
                        ).join('<br>')}
                    </div>
                </div>
            `;

            container.innerHTML = html;
        }

        /**
         * Add test result
         */
        function addResult(category, testName, success, message) {
            testResults[category].push({
                testName,
                success,
                message,
                timestamp: new Date().toISOString()
            });
        }

        /**
         * Clear all results
         */
        function clearResults() {
            testResults = {
                integration: [],
                performance: [],
                errors: []
            };

            document.getElementById('integration-results').innerHTML = 
                '<div class="test-info">Integration test results will appear here</div>';
            document.getElementById('performance-results').innerHTML = 
                '<div class="test-info">Performance test results will appear here</div>';
            document.getElementById('performance-metrics').innerHTML = 
                '<div class="test-info">Performance metrics will appear here after running tests</div>';
        }

        /**
         * Export test results
         */
        function exportResults() {
            const allResults = {
                timestamp: new Date().toISOString(),
                integration: testResults.integration,
                performance: testResults.performance,
                metrics: performanceOptimizer ? performanceOptimizer.getPerformanceMetrics() : null
            };

            const dataStr = JSON.stringify(allResults, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `task11_test_results_${new Date().toISOString().split('T')[0]}.json`;
            link.click();
        }

        /**
         * Setup sample data for testing
         */
        function setupSampleData() {
            const sampleMasterBarang = [
                {
                    kode: 'AQUA-DUS',
                    nama: 'Aqua 1L DUS',
                    baseProduct: 'AQUA-1L',
                    kategori: 'minuman',
                    satuan: 'dus',
                    stok: 10,
                    hargaBeli: 12000,
                    hargaJual: 15000
                },
                {
                    kode: 'AQUA-PCS',
                    nama: 'Aqua 1L PCS',
                    baseProduct: 'AQUA-1L',
                    kategori: 'minuman',
                    satuan: 'pcs',
                    stok: 50,
                    hargaBeli: 1000,
                    hargaJual: 1250
                }
            ];

            const sampleConversionRatios = [
                {
                    baseProduct: 'AQUA-1L',
                    conversions: [
                        { from: 'dus', to: 'pcs', ratio: 12 },
                        { from: 'pcs', to: 'dus', ratio: 1/12 }
                    ]
                }
            ];

            localStorage.setItem('masterBarang', JSON.stringify(sampleMasterBarang));
            localStorage.setItem('conversionRatios', JSON.stringify(sampleConversionRatios));
            localStorage.setItem('transformationHistory', JSON.stringify([]));
            localStorage.setItem('currentUser', 'kasir01');
        }

        /**
         * Generate large dataset for performance testing
         */
        function generateLargeDataset(count) {
            const items = [];
            const categories = ['minuman', 'makanan', 'alat-tulis', 'elektronik'];
            const units = ['pcs', 'dus', 'box', 'kg'];

            for (let i = 0; i < count; i++) {
                const baseProduct = `PRODUCT-${Math.floor(i / 4)}`;
                items.push({
                    kode: `ITEM-${i}`,
                    nama: `Item ${i}`,
                    baseProduct: baseProduct,
                    kategori: categories[i % categories.length],
                    satuan: units[i % units.length],
                    stok: Math.floor(Math.random() * 100) + 1,
                    hargaBeli: Math.floor(Math.random() * 10000) + 1000,
                    hargaJual: Math.floor(Math.random() * 15000) + 1500
                });
            }

            return items;
        }

        /**
         * Create mock UI elements for testing
         */
        function createMockUIElements() {
            const elements = [];
            const elementIds = ['sourceItem', 'targetItem', 'quantity', 'preview-container'];
            
            elementIds.forEach(id => {
                const element = document.createElement('div');
                element.id = id;
                document.body.appendChild(element);
                elements.push(element);
            });

            return elements;
        }

        /**
         * Cleanup mock UI elements
         */
        function cleanupMockUIElements(elements) {
            elements.forEach(element => {
                if (element.parentNode) {
                    element.parentNode.removeChild(element);
                }
            });
        }
    </script>
</body>
</html>